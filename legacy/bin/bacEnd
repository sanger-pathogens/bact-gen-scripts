#!/usr/local/bin/perl

# Copyright @ 2002, 2003 The Institute for Genomic Research (TIGR).  All
# rights reserved.

# $Id: bacEnd.pl,v 1.3 2003/02/24 17:33:00 mpop Exp $

# this program takes as input tabular output coming from blast
# together with the lengths of contigs and information about 
# the bac libraries chosen and it generates bamboo input files.

use TIGR::Foundation;
use strict;

my $base = new TIGR::Foundation;
$base->setVersionInfo('$Revision: 1.3 $ ');

my $HELP = q~
    bacEnd.pl 
        -l <libfile>   libId to size range mapping 
        -b <bacfile>   bacId to length mapping
        -c <ctgfile>   contigId to length mapping
        -t <tabfile>   output of blastall -m 8
        -m <mapfile>   bacId to libId mapping
        -r <repeatfile> ignore repeats
        -len <diff>    maximum difference between read length and hit length
                       for valid hits
        -mummer        tab file was generated by mummer
    ~;

$base->setHelpInfo($HELP);

my $LENDIFF = 50;
my $REPEAT_RANGE = 30; # minimum overlap with repeat
my $tabfile;   # tab output from blastall -m 8 or nucmer
my $ctgfile;   # contig lengths
my $bacfile;   # bac lengths
my $libfile;   # library sizes
my $mapfile;   # mapping between bacs and libraries
my $filetype;
my $repfile;   # location of repeats

my $err = $base->TIGR_GetOptions(
				 "l=s" => \$libfile,
				 "b=s" => \$bacfile,
				 "c=s" => \$ctgfile,
				 "t=s" => \$tabfile,
				 "m=s" => \$mapfile,
				 "r=s" => \$repfile,
				 "len=i" => \$LENDIFF,
				 "mummer" => \$filetype
				 );

if (defined $filetype){
    $filetype = "mummer";
} else {
    $filetype = "blast";
}

my %libs;  # library size hash
my %contigs;  # contigs size hash
my %bacs;   # bac size hash
my %bacmap; # bac ID to lib ID mapping
my %lib2bac; # lib ID to bac ID mapping
my %repeats; # repeats to be ignored

if (defined $repfile) {
    open (REP, $repfile) || 
	$base->bail("Cannot open $repfile: $!");
    while (<REP>){
	if (/^\#/){
	    next; # skip comments
	}
	chomp;
	my @vals = split("\t", $_);
	push(@{$repeats{$vals[0]}}, "$vals[2] $vals[3]");
    }
    close(REP);
}

print STDERR "**reading libraries\n";
open(LIB, $libfile) ||
    $base->bail("Cannot open $libfile: $!");

while (<LIB>){
    my @fields = split('\t', $_);
    $libs{$fields[0]} = "$fields[1] $fields[3]";
}

close(LIB);

print STDERR "**reading contig lengths\n";
open(CTG, $ctgfile) ||
    $base->bail("Cannot open $ctgfile: $!");

while (<CTG>){
    my @fields = split(' ', $_);
    $contigs{$fields[0]} = $fields[1];
}

close(CTG);

print STDERR "**reading bac lengths\n";
open(BAC, $bacfile) ||
    $base->bail("Cannot open $bacfile: $!");

while (<BAC>){
    my @fields = split(' ', $_);
    $bacs{$fields[0]} = $fields[1];
}

close(BAC);

print STDERR "**reading bac2lib mapping\n";
open(BACLIB, $mapfile) ||
    $base->bail("Cannot open $mapfile: $!");

while (<BACLIB>){
    my @fields = split(' ', $_);
    $bacmap{$fields[0]} = $fields[1];
    $lib2bac{$fields[1]} .= "$fields[0] ";
}
close(BACLIB);

my %bachit;      # contig hit by bac end
my %bachitlen;   # length of hit
my %bachitper;   # % id of hit
my %bachitforw;   # orientation of hit
my %bachitcoord; # coordinates of hit
my %ctgbac;      # map between contigs and bacs

print STDERR "**Parsing blast hits\n";
open(TAB, $tabfile) || 
    $base->bail("Cannot open $tabfile: $!");

while (my $rec = getTabRecord(\*TAB)){
    chomp $rec;
    my $fields = parseTabRecord($rec, $filetype);
    if (! defined $fields){
	print STDERR "skipping funny record: $rec";
	next;
    }

    my $bac = $$fields{query};
    my $ctg = $$fields{ref};

    if (exists $bachit{$bac}){
	if ($$fields{perId} < $bachitper{$bac} ||
	    $$fields{matchLen} < $bachitlen{$bac}){
	    print STDERR "Match between $bac and $bachit{$bac} ($bachitlen{$bac}, $bachitper{$bac})is better than match between $bac and $ctg ($$fields{matchLen} $$fields{perId})\n";
	    next; # this match is no good
	}
    }

    my $bl = ($$fields{refStart} > $$fields{refEnd}) ? $$fields{refEnd} : $$fields{refStart};
    my $br = ($$fields{refStart} > $$fields{refEnd}) ? $$fields{refStart} : $$fields{refEnd};

    if (exists $repeats{$ctg}){
	my @reps = @{$repeats{$ctg}};
	my $keep = 1;
	for (my $r = 0; $r <= $#reps; $r++){
	    my ($l, $r) = split(' ', $reps[$r]);
	    if ($bl <= $r && $br >= $l){
		# we hit a repeat
		$keep = 0;
		next;
	    }
	}
	if (! $keep) {
	    next; # skip hit in repeat
	}
    }
    
    $bachit{$bac} = $ctg;
    $bachitlen{$bac} = $$fields{matchLen};
    $bachitper{$bac} = $$fields{perId};
    $bachitforw{$bac} = ($$fields{refStart} > $$fields{refEnd})? 0 : 1;
    $bachitcoord{$bac} = "$$fields{refStart} $$fields{refEnd}";
    $ctgbac{$ctg} .= "$bac ";
}

print STDERR "**Cleaning up bad hits\n";
while (my ($bac, $ctg) = each %bachit){
    if ($bacs{$bac} - $bachitlen{$bac} > $LENDIFF){
	print STDERR "Skipping short hit between $bac and $ctg ($bacs{$bac} vs $bachitlen{$bac})\n";
	delete $bachit{$bac};
	delete $bachitlen{$bac};
	delete $bachitper{$bac};
	delete $bachitforw{$bac};
	delete $bachitcoord{$bac};
    }
}

my @links;
print STDERR "**Finding pairs\n";
while (my ($bac, $ctg) = each %bachit){
    my $mate = getMate($bac);
    if ($mate lt $bac) {
	next;  # so we don't handle the same mate pair twice
    }
    if (exists $bachit{$mate} && ($ctg ne $bachit{$mate})){
	push(@links, "$bac $mate");
    }

    if (exists $bachit{$mate} && ($ctg eq $bachit{$mate})){
	print STDERR "both $bac and $mate are in contig $ctg\n";
    }

    if (! exists $bachit{$mate}){
	print STDERR "Cannot find hit for mate $mate\n";
    }
}

my $date = localtime;
print STDERR "Generating output\n";
print "<?xml version=\"1.0\" ?>\n";
print "<EVIDENCE ID=\"project_1\" DATE=\"$date\" PROJECT=\"$tabfile\" PARAMETERS=\"\"\>\n";

while (my ($lib, $range) = each %libs){
    my ($min, $max) = split(' ', $range);
    print "  <LIBRARY ID=\"lib_$lib\" NAME=\"$lib\" MIN=\"$min\" MAX=\"$max\">\n";

    my @bacs = split(' ', $lib2bac{$lib});
    for (my  $i = 0; $i <= $#bacs; $i++){
	if (! exists $bachit{$bacs[$i]}) { # only output the "useful" bacs
	    next;
	}

	my $mate = getMate($bacs[$i]);
	if (exists $bacs{$mate} && $mate gt $bacs[$i]){
	    print "    <INSERT ID=\"ins_$bacs[$i]\" NAME=\"$bacs[$i]\">\n";
	    print "       <SEQUENCE ID=\"seq_$bacs[$i]\" NAME=\"$bacs[$i]\"/>\n";
	    print "       <SEQUENCE ID=\"seq_$mate\" NAME=\"$mate\"/>\n";
	    print "    </INSERT>\n";
	}
    }
    print "  </LIBRARY>\n";
}

while (my ($ctg, $len) = each %contigs){
    print "  <CONTIG ID=\"ctg_$ctg\" NAME=\"$ctg\" LEN=\"$len\">\n";
    if (exists $ctgbac{$ctg}){
	my @bacs = split(' ', $ctgbac{$ctg});
	for (my $i = 0; $i <= $#bacs; $i++){
	    if (! exists $bachit{$bacs[$i]}){
		next;
	    }
	    my $ori = ($bachitforw{$bacs[$i]} == 1) ? "BE" : "EB";
	    my ($alend, $arend) = split(' ', $bachitcoord{$bacs[$i]});
	    print "    <SEQUENCE ID=\"seq_$bacs[$i]\" ORI=\"$ori\" ASM_LEND=\"$alend\" ASM_REND=\"$arend\"/>\n";
	}
    }

    print "   </CONTIG>\n";
}

print "</EVIDENCE>\n";

exit(0);

# retrieves the next tabular record
sub getTabRecord
{
    my $file = shift;
    
    return <$file>;  # simply return next line in the file
}

# parses a tab delimited blastall line into the important information
# returned as a hash table
sub parseTabRecord
{
    my $rec = shift;
    my $type = shift;

    my %retvals;

    my @fields = split('\t', $rec);

    if ($type eq "blast"){
	if ($#fields != 11){
	    return undef;
	}
	
	$retvals{"query"} = $fields[0];
	$retvals{"ref"} = $fields[1];
	$retvals{"perId"} = $fields[2];
	$retvals{"matchLen"} = $fields[3];
	$retvals{"queryStart"} = $fields[6];
	$retvals{"queryEnd"} = $fields[7];
	$retvals{"refStart"} = $fields[8];
	$retvals{"refEnd"} = $fields[9];
	$retvals{"pValue"} = $fields[10];
    } elsif ($type eq "mummer"){
	if ($#fields != 8){
	    return undef;
	}

	$retvals{"query"} = $fields[8];
	$retvals{"ref"} = $fields[7];
	$retvals{"perId"} = $fields[6];
	$retvals{"matchLen"} = $fields[5];
	# here we assume that the query coords are always in the 
	# forward direction.
	if ($fields[2] > $fields[3]){
	    $retvals{"queryStart"} = $fields[3];
	    $retvals{"queryEnd"} = $fields[2];
	    $retvals{"refStart"} = $fields[1];
	    $retvals{"refEnd"} = $fields[0];
	} else {
	    $retvals{"queryStart"} = $fields[2];
	    $retvals{"queryEnd"} = $fields[3];
	    $retvals{"refStart"} = $fields[0];
	    $retvals{"refEnd"} = $fields[1];
	}
	$retvals{"pValue"} = 0;
    }
	
    return \%retvals;
}

# returns the potential mate of a particular sequence
# assuming all sequences end in .F or .R
sub getMate
{
    my $seq = shift;

    $seq =~ /^(.*)\.([FR])$/;
    if (! defined $1){
	$base->bail("Wierd name this one: $seq");
    }
    if ($2 eq "F"){ # name is forward
	return "$1.R";
    } else {        # name is reverse
	return "$1.F";
    }
}
