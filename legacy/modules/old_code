	
	

def parsimonious_SNP_reconstruction(treeObject, alignmentObject, locations=[], transformation="acctran"):
	

	def reconstruct_ancestral_states(treeObject, node):
		
		daughters=treeObject.node(node).get_succ()
		daughterstates={}
		
		for daughter in daughters:
			#contents of getdata object {'branchlength': 1.1926700000000001, 'comment': None, 'support': 0.0, 'taxon': 'seq5'}
			
			if not treeObject.node(daughter).get_data().comment:
				#print treeObject.node(daughter).get_data().comment
				treeObject=reconstruct_ancestral_states(treeObject, daughter)
				#print treeObject.node(daughter).get_data().comment
			
			
			#daughterstates.append[treeObject.node(daughter).get_data().comment]
			
			for state in treeObject.node(daughter).get_data().comment:
				if not daughterstates.has_key(state):
					daughterstates[state]=0
				daughterstates[state]+=1
			
			
		maxvalue=0
		maxstates=["?"]
		for key in daughterstates.keys():
			if key in ["?", "-", "N", "X"]:
				continue
			if daughterstates[key]==maxvalue:
				maxstates.append(key)
			elif daughterstates[key]>maxvalue:
				maxstates=[key]
				maxvalue=daughterstates[key]
			
		
		data=treeObject.node(node).get_data()
		data.comment=maxstates
		treeObject.node(node).set_data(data)
			
		
		return treeObject
	
	
	
	def parsimony_reconstruction_of_ancestral_states(treeObject, node, substitutions=[]):
		
		
		
		daughters=treeObject.node(node).get_succ()
		
		node_states=treeObject.node(node).get_data().comment
		
		if treeObject.node(node).get_data().comment==False:
			DoError("Trying to reconstruct acctran parsimony without nodes having states")
		elif len(treeObject.node(node).get_data().comment)>1:
			alternative_reconstructions=True
		else:
			alternative_reconstructions=False
		
		node_state=treeObject.node(node).get_data().comment[0]
		
		for daughter in daughters:
			if not node_state in treeObject.node(daughter).get_data().comment and not treeObject.node(daughter).get_data().comment[0] in ["?", "-", "N", "X"]:
				#print "change from", node, "to", daughter, treeObject.node(node).get_data().comment[0], treeObject.node(daughter).get_data().comment[0]
				
				if treeObject.is_internal(daughter):
					daughtername="node_"+str(daughter)
				else:
					daughtername=treeObject.node(daughter).get_data().taxon
				
				nodename="node_"+str(node)
				
				substitutions.append([nodename, daughtername, treeObject.node(node).get_data().comment[0], treeObject.node(daughter).get_data().comment[0]])
				data=treeObject.node(daughter).get_data()
				brlen=float(data.branchlength)
				data.branchlength=brlen+1
				treeObject.node(daughter).set_data(data)
			else:
				data=treeObject.node(daughter).get_data()
				data.comment=[node_state]
				treeObject.node(daughter).set_data(data)
				
			if treeObject.is_internal(daughter):
				
				treeObject, substitutions=parsimony_reconstruction_of_ancestral_states(treeObject, daughter, substitutions)
			
		return treeObject, substitutions
		
	

	def is_homoplasic(substitutions):
		
		already_seen=[]

		for substitution in substitutions:
			if substitution[3] in already_seen:
				return True
			already_seen.append(substitution[2])
			already_seen.append(substitution[3])

		return False	
		
	
	
	def clear_branchlengths(treeObject, node):
		
		daughters=treeObject.node(node).get_succ()
		
		for daughter in daughters:
			treeObject=clear_branchlengths(treeObject, daughter)	
		
		data=treeObject.node(node).get_data()
		data.branchlength=0
		treeObject.node(node).set_data(data)
	
		return treeObject
	
	
	
	def clear_internal_branch_comments(treeObject, node):
		
		daughters=treeObject.node(node).get_succ()
		
		for daughter in daughters:
			if treeObject.is_internal(daughter):
				treeObject=clear_internal_branch_comments(treeObject, daughter)
			
		
		data=treeObject.node(node).get_data()
		data.comment=False
		treeObject.node(node).set_data(data)
	
		return treeObject
		
		
	def support_to_node_names(treeObject, node):
		
		daughters=treeObject.node(node).get_succ()
		
		for daughter in daughters:
			treeObject=support_to_node_names(treeObject, daughter)
			
		
		data=treeObject.node(node).get_data()
		data.support=node
		treeObject.node(node).set_data(data)
	
		return treeObject
		
	
	
	
		
		
	rootnode=treeObject.root
	
	#clear the branchlengths so they can be replced with SNP counts
	treeObject=clear_branchlengths(treeObject, rootnode)
	
	
	taxa=[]
	
	for taxon in alignmentObject:
		taxa.append(taxon.id)
	
	
	taxadata={}
	substitutions={}
	
	if locations==[]:
		locations=range(alignmentObject.get_alignment_length())
	
	for columnnumber in locations:
		
		#when we get the new version of biopython, this can be changed to slice notation alignmentObject[:,base]
		column=alignmentObject.get_column(columnnumber)
		
		for taxonnumber, taxon in enumerate(taxa):
			taxadata[taxon]=column[taxonnumber].upper()
	
		for node in treeObject.get_terminals():
			data=treeObject.node(node).get_data()
			data.comment=[taxadata[data.taxon]]
			treeObject.node(node).set_data(data)
			
		
		treeObject=reconstruct_ancestral_states(treeObject, rootnode)
		substitutions[columnnumber]=[]
		treeObject, substitutions[columnnumber]=parsimony_reconstruction_of_ancestral_states(treeObject, rootnode, substitutions[columnnumber])
		if is_homoplasic(substitutions[columnnumber]):
			substitutions[columnnumber].append(True)
		else:
			substitutions[columnnumber].append(False)
			
		treeObject=clear_internal_branch_comments(treeObject, rootnode)
		
		
#	midpoint root the SNP tree (for aesthetic reasons)
#	midpoint_root(treeObject)
#	
#	reassign the root node to the new midpoint root
#	rootnode=treeObject.root
	
	treeObject=support_to_node_names(treeObject, rootnode)
		
	treestring= tree_to_string(treeObject, False, False, False, False)

	if treestring[-1]==";":
		treestring=treestring.replace(";", str(rootnode)+";")
	else:
		treestring=treestring=treestring+str(rootnode)+";"
	treestring="("+"(".join(treestring.split("(")[1:])
	
	return treestring, substitutions
	
	
	
	



def get_homoplasy_blocks_3(treeObject, handle):

	root=treeObject.root
	#handle=open("test.tab","w")


	homoplasy_list={}

	def count_diffs(node1, node2, start, end):

		seq1=treeObject.node(node1).get_data().comment["sequence"][start:end]

		seq2=treeObject.node(node2).get_data().comment["sequence"][start:end]
		numdiffs=0
		for x, ambiguity1 in enumerate(seq1):

			bases1=set(ambiguity_to_bases[ambiguity1])
			bases2=set(ambiguity_to_bases[seq2[x]])

			if "-" in bases1:
				bases1.remove("-")
			elif "-" in bases2:
				bases2.remove("-")
			
			#print bases1, bases2, bases1.union(bases2)
			
			if len(bases1.intersection(bases2))==0:
				numdiffs+=1
		
		#print node1, node2, start, end, numdiffs
		return numdiffs
	
	def find_blocks(node, homoplasy_list):
	
		data=treeObject.node(node).get_data().comment
		#root_branches=treeObject.node(root).get_succ()
		#if node==root_branches[1]:
		#	return
		
		if data.has_key("SNP_locations"):

			locations=data["SNP_locations"].keys()
			locations.sort()

			
			blocks={}
			rev_blocks={}
			new_blocks={}
			
			for location in locations:
				if data["SNP_locations"][location].homoplasy:

					if not homoplasy_list.has_key(location):
						homoplasy_list[location]=[]
				   		
					for homoplasy in data["SNP_locations"][location].homoplasies:
						#if homoplasy[0]=="c":
						#print homoplasy
						
						if not blocks.has_key(homoplasy[1]):
							blocks[homoplasy[1]]=[]
						blocks[homoplasy[1]].append(location)
						
						#
#						revnode=homoplasy[1]
#						for homoplasy in treeObject.node(revnode).get_data().comment["SNP_locations"][location].homoplasies:
#							if homoplasy[1]==node:
#								if homoplasy[0]=="r" and treeObject.common_ancestor(revnode, homoplasy[1])==homoplasy[1]:
#									rev_blocks[location]=[treeObject.node(revnode).get_prev(), revnode, "f", set(), "r"]
#									rev_blocks[location][3]=rev_blocks[location][3].union(set(get_upstream_nodes(treeObject, homoplasy[1])))
#								elif homoplasy[0]=="c":
#									rev_blocks[location]=[treeObject.node(revnode).get_prev(), revnode, "f", set(), "f"]
#									rev_blocks[location][3]=rev_blocks[location][3].union(set([treeObject.node(homoplasy[1]).get_prev()]+get_downstream_nodes(treeObject, homoplasy[1])))
#								else:
#									rev_blocks[location]=[treeObject.node(revnode).get_prev(), revnode, "r", set(), "f"]
#									rev_blocks[location][3]=rev_blocks[location][3].union(set([treeObject.node(homoplasy[1]).get_prev()]+get_downstream_nodes(treeObject, homoplasy[1])))
#						
#						homoplasy_list[location].append(rev_blocks[location])
					
					#print location, blocks[location], rev_blocks[location]
						
		
		
		
		
		#for 
		
		
					

		return homoplasy_list

	def iterate_nodes(node, homoplasy_list):
		daughters=treeObject.node(node).get_succ()

		for daughter in daughters:
			homoplasy_list=iterate_nodes(daughter, homoplasy_list)

		homoplasy_list=find_blocks(node, homoplasy_list)
		return homoplasy_list
		


	homoplasy_list=iterate_nodes(root, homoplasy_list)
	handle.close()

	keys= homoplasy_list.keys()
	keys.sort()
	
	for key in keys:
		print key, homoplasy_list[key]





def get_homoplasy_blocks_3(treeObject, handle):

	root=treeObject.root
	#handle=open("test.tab","w")


	homoplasy_list={}

	def count_diffs(node1, node2, start, end):

		seq1=treeObject.node(node1).get_data().comment["sequence"][start:end]

		seq2=treeObject.node(node2).get_data().comment["sequence"][start:end]
		numdiffs=0
		for x, ambiguity1 in enumerate(seq1):

			bases1=set(ambiguity_to_bases[ambiguity1])
			bases2=set(ambiguity_to_bases[seq2[x]])

			if "-" in bases1:
				bases1.remove("-")
			elif "-" in bases2:
				bases2.remove("-")
			
			#print bases1, bases2, bases1.union(bases2)
			
			if len(bases1.intersection(bases2))==0:
				numdiffs+=1
		
		#print node1, node2, start, end, numdiffs
		return numdiffs
	
	def find_blocks(node, homoplasy_list):
	
		data=treeObject.node(node).get_data().comment
		#root_branches=treeObject.node(root).get_succ()
		#if node==root_branches[1]:
		#	return
		
		if data.has_key("SNP_locations"):

			locations=data["SNP_locations"].keys()
			locations.sort()

			
			blocks={}
			rev_blocks={}
			new_blocks={}
			
			for location in locations:
				if data["SNP_locations"][location].homoplasy:

					if not homoplasy_list.has_key(location):
						homoplasy_list[location]=[]
				   		
					for homoplasy in data["SNP_locations"][location].homoplasies:
						#if homoplasy[0]=="c":
						#print homoplasy
						if homoplasy[0]=="r" and treeObject.common_ancestor(node, homoplasy[1])==homoplasy[1]:
							blocks[location]=[treeObject.node(node).get_prev(), node, "f", set(), "r"]
							blocks[location][3]=blocks[location][3].union(set(get_upstream_nodes(treeObject, homoplasy[1])))
						elif homoplasy[0]=="c":
							blocks[location]=[treeObject.node(node).get_prev(), node, "f", set(), "f"]
							blocks[location][3]=blocks[location][3].union(set([treeObject.node(homoplasy[1]).get_prev()]+get_downstream_nodes(treeObject, homoplasy[1])))
						else:
							blocks[location]=[treeObject.node(node).get_prev(), node, "r", set(), "f"]
							blocks[location][3]=blocks[location][3].union(set([treeObject.node(homoplasy[1]).get_prev()]+get_downstream_nodes(treeObject, homoplasy[1])))
						homoplasy_list[location].append(blocks[location])
#						revnode=homoplasy[1]
#						for homoplasy in treeObject.node(revnode).get_data().comment["SNP_locations"][location].homoplasies:
#							if homoplasy[1]==node:
#								if homoplasy[0]=="r" and treeObject.common_ancestor(revnode, homoplasy[1])==homoplasy[1]:
#									rev_blocks[location]=[treeObject.node(revnode).get_prev(), revnode, "f", set(), "r"]
#									rev_blocks[location][3]=rev_blocks[location][3].union(set(get_upstream_nodes(treeObject, homoplasy[1])))
#								elif homoplasy[0]=="c":
#									rev_blocks[location]=[treeObject.node(revnode).get_prev(), revnode, "f", set(), "f"]
#									rev_blocks[location][3]=rev_blocks[location][3].union(set([treeObject.node(homoplasy[1]).get_prev()]+get_downstream_nodes(treeObject, homoplasy[1])))
#								else:
#									rev_blocks[location]=[treeObject.node(revnode).get_prev(), revnode, "r", set(), "f"]
#									rev_blocks[location][3]=rev_blocks[location][3].union(set([treeObject.node(homoplasy[1]).get_prev()]+get_downstream_nodes(treeObject, homoplasy[1])))
#						
#						homoplasy_list[location].append(rev_blocks[location])
					
					#print location, blocks[location], rev_blocks[location]
						
					

		return homoplasy_list

	def iterate_nodes(node, homoplasy_list):
		daughters=treeObject.node(node).get_succ()

		for daughter in daughters:
			homoplasy_list=iterate_nodes(daughter, homoplasy_list)

		homoplasy_list=find_blocks(node, homoplasy_list)
		return homoplasy_list
		


	homoplasy_list=iterate_nodes(root, homoplasy_list)
	handle.close()

	keys= homoplasy_list.keys()
	keys.sort()
	
	for key in keys:
		print key, homoplasy_list[key]
		
		
		
		
def get_homoplasy_blocks_old(treeObject, handle):

	root=treeObject.root
	#handle=open("test.tab","w")


	def count_diffs(node1, node2, start, end):

		seq1=treeObject.node(node1).get_data().comment["sequence"][start:end]

		seq2=treeObject.node(node2).get_data().comment["sequence"][start:end]
		numdiffs=0
		for x, ambiguity1 in enumerate(seq1):

			bases1=set(ambiguity_to_bases[ambiguity1])
			bases2=set(ambiguity_to_bases[seq2[x]])

			if "-" in bases1:
				bases1.remove("-")
			elif "-" in bases2:
				bases2.remove("-")
			
			#print bases1, bases2, bases1.union(bases2)
			
			if len(bases1.intersection(bases2))==0:
				numdiffs+=1
		
		print node1, node2, start, end, numdiffs
		return numdiffs
	
	
	
	def count_diffs_for_seqs(seq1, seq2):
		numdiffs=0
		for x, ambiguity1 in enumerate(seq1):

			bases1=set(ambiguity_to_bases[ambiguity1])
			bases2=set(ambiguity_to_bases[seq2[x]])

			if "-" in bases1:
				bases1.remove("-")
			elif "-" in bases2:
				bases2.remove("-")
			
			#print bases1, bases2, bases1.union(bases2)
			
			if len(bases1.intersection(bases2))==0:
				numdiffs+=1
		
		print numdiffs
		return numdiffs
	
	
		
		
	def get_consensus(seq1, seq2):
		
		consensus_seq=""
		
		numdiffs=0
		for x, ambiguity1 in enumerate(seq1):
		
			bases1=set(ambiguity_to_bases[ambiguity1])
			bases2=set(ambiguity_to_bases[seq2[x]])
			
			union=bases1.union(bases2)
			
			union_list=list(union)
			union_list.sort()
			
			consensus_seq=consensus_seq+bases_to_ambiguity[''.join(union_list)]
		
		return consensus_seq
		
	
	def find_blocks(node):


## 		data=treeObject.node(node).get_data().comment

## 		if data.has_key("SNP_locations"):

## 			locations=data["SNP_locations"].keys()
## 			locations.sort()

## 			inblock="n"
## 			blocks={}
## 			matchingnodes=[]
			
## 			for location in locations:
## 				if data["SNP_locations"][location].homoplasy:

				   	
## 					for homoplasy in data["SNP_locations"][location].homoplasies:
## 						if homoplasy[0]=="c":
## 							if not blocks.has_key(homoplasy[1]):
## 								blocks[homoplasy[1]]=[]
## 							blocks[homoplasy[1]].append(location)
## 					inblock="y"
					


## 			minrecombinations={}
## 			maxrecombinations={}






#			for key in blocks.keys():

## 				maxrecombinations[key]=[]
## 				minrecombinations[key]=[]
				
## 			   		x=1

## 				inrecombination=False
## 				inundecided=False
## 				undhasrecomb=False
## 				recstart=-1
## 				undstart=-1
## 				undend=-1
## 				recend=-1
## 				diffs=0
				
## 			   		while x<len(blocks[key]):
## 			   			hom=count_diffs(node, treeObject.node(key).get_prev(), blocks[key][x-1], blocks[key][x])
## 			   			non=count_diffs(node, treeObject.node(node).get_prev(), blocks[key][x-1], blocks[key][x])

					
## 			   			if non==hom:
			   				
## 						if not inundecided:
## 							inundecided=True
## 							undstart=blocks[key][x-1]
						
## 						undend=blocks[key][x]
## 			   			elif hom<non:
## 						#print "recombination"
## 						if not inrecombination:
## 							inrecombination=True
## 							recstart=blocks[key][x-1]
## 						if not inundecided:
## 							inundecided=True
## 							undstart=blocks[key][x-1]
## 						if not undhasrecomb:
## 							undhasrecomb=True
## 						recend=blocks[key][x]
## 						undend=blocks[key][x]
## 						diffs=diffs+(non-hom)
## 					else:
## 						if inundecided:
## 							if undhasrecomb:
## 								maxrecombinations[key].append([undstart, undend, diffs])
## 							undstart=-1
## 							undend=-1
## 							inundecided=False
## 							undhasrecomb=False
## 						if inrecombination:
## 							minrecombinations[key].append([recstart,recend, diffs])
## 							recstart=-1
## 							recend=-1
## 							inrecombination=False
## 						diffs=0
							
## 					x+=1

## 				if inundecided and undhasrecomb:
## 			  			maxrecombinations[key].append([undstart, undend, diffs])
## 				   		undstart=-1
## 					   	undend=-1
## 					inundecided=False
## 					undhasrecomb=False
## 				if inrecombination:
## 					minrecombinations[key].append([recstart,recend, diffs])
## 					recstart=-1
## 					recend=-1
## 					inrecombination=False

## 				if len(maxrecombinations[key])>0:
## 					print node, key
## 					print maxrecombinations[key]
## 					print minrecombinations[key]
## 					for part in maxrecombinations[key]:
## 						print >> handle, "FT   recombination   "+str(part[0])+".."+str(part[1])
## 						print >> handle, 'FT				   /node='+str(key)+'->'+str(node)
## 						print >> handle, "FT				   /SNPs="+str(part[2])






		data=treeObject.node(node).get_data().comment
		root_branches=treeObject.node(root).get_succ()
		if node==root_branches[1]:
			return
		
		if data.has_key("SNP_locations"):

			locations=data["SNP_locations"].keys()
			locations.sort()

			
			blocks=[]
			matchingnodes=[]
			
			for location in locations:
				if data["SNP_locations"][location].homoplasy:

				   	
					for homoplasy in data["SNP_locations"][location].homoplasies:
						#if homoplasy[0]=="c":
						if homoplasy[1] in root_branches:
							blocks.append([location, root_branches[0], homoplasy[0]])
						else:
							blocks.append([location, homoplasy[1], homoplasy[0]])
					

			if node==root_branches[0]:
				data=treeObject.node(root_branches[1]).get_data().comment
				if data.has_key("SNP_locations"):
					locations=data["SNP_locations"].keys()
					for location in locations:
						if data["SNP_locations"][location].homoplasy:
							
				   	
							for homoplasy in data["SNP_locations"][location].homoplasies:
						
								if homoplasy[1] in root_branches:
									blocks.append([location, root_branches[0], homoplasy[0]])
								else:
									blocks.append([location, homoplasy[1], homoplasy[0]])
									


			minrecombinations=[]
			maxrecombinations=[]
			
			
				
			x=1

			inrecombination=False
			inundecided=False
			undhasrecomb=False
			recstart=-1
			undstart=-1
			undend=-1
			recend=-1
			diffs=0
			startblock=0
			print node, blocks
			while x<len(blocks):
			
				start=blocks[x-1][0]
				end=blocks[x][0]+1
			
			
				seq1=treeObject.node(node).get_data().comment["sequence"][start:end]
				
				print start, end, treeObject.node(blocks[x][1]).get_prev(), blocks[x][1], 
				
				seq2=get_consensus(treeObject.node(treeObject.node(blocks[x][1]).get_prev()).get_data().comment["sequence"][start:end], treeObject.node(blocks[x][1]).get_data().comment["sequence"][start:end])
				
				hom=count_diffs_for_seqs(seq1, seq2)
				
				print start, end, treeObject.node(node).get_prev(), node, 
				
				seq2=treeObject.node(treeObject.node(node).get_prev()).get_data().comment["sequence"][start:end]
				
				non=count_diffs_for_seqs(seq1, seq2)
				
			
#				if blocks[x][2]=="r":
#
#					hom=count_diffs(node, treeObject.node(blocks[x][1]).get_prev(), blocks[x-1][0], blocks[x][0]+1)
#				else:
#					hom=count_diffs(node, blocks[x][1], blocks[x-1][0], blocks[x][0]+1)
#				non=count_diffs(node, treeObject.node(node).get_prev(), blocks[x-1][0], blocks[x][0]+1)

				
#				if blocks[x-1][1]!=blocks[x][1]:
#					#alt=count_diffs(node, treeObject.node(blocks[x-1][1]).get_prev(), blocks[x-1][0], blocks[x][0]+1)
#					if blocks[x-1][2]=="r":
#						alt=count_diffs(node, treeObject.node(blocks[x-1][1]).get_prev(), blocks[x-1][0], blocks[x][0]+1)
#					else:
#						alt=count_diffs(node, blocks[x-1][1], blocks[x-1][0], blocks[x][0]+1)
#					if alt<hom and alt<non:
#						hom=alt
#						blocks[x][1]=blocks[x-1][1]
#				
#					elif hom<alt and hom<non:
#						blocks[startblock][1]=blocks[x][1]
#						x=startblock
#						continue
				#print non, hom

				compnode=blocks[x][1]

				if non==hom:

					if not inundecided:
						inundecided=True
						undstart=blocks[x-1][0]
						startblock=x-1

					undend=blocks[x][0]
				elif hom<non:
					#print "recombination"
					if not inrecombination:
						inrecombination=True
						recstart=blocks[x-1][0]
					if not inundecided:
						inundecided=True
						undstart=blocks[x-1][0]
						startblock=x-1
					if not undhasrecomb:
						undhasrecomb=True
					recend=blocks[x][0]
					undend=blocks[x][0]
					diffs=diffs+(non-hom)
				else:
					if inundecided:
						if undhasrecomb:
							maxrecombinations.append([undstart, undend, diffs, compnode])
						undstart=-1
						undend=-1
						startblock=-1
						inundecided=False
						undhasrecomb=False
					if inrecombination:
						minrecombinations.append([recstart,recend, diffs, compnode])
						recstart=-1
						recend=-1
						inrecombination=False
					diffs=0

				x+=1

			if inundecided and undhasrecomb:
				maxrecombinations.append([undstart, undend, diffs, compnode])
				undstart=-1
				undend=-1
				inundecided=False
				undhasrecomb=False
			if inrecombination:
				minrecombinations.append([recstart,recend, diffs, compnode])
				recstart=-1
				recend=-1
				inrecombination=False

			if len(maxrecombinations)>0:
				print node
				print maxrecombinations
				print minrecombinations
				for part in maxrecombinations:
					print >> handle, "FT   recombination   "+str(part[0])+".."+str(part[1])
					print >> handle, 'FT                   /node='+str(part[3])+'->'+str(node)
					print >> handle, "FT                   /SNPs="+str(part[2])
				

	def iterate_nodes(node):
		daughters=treeObject.node(node).get_succ()

		for daughter in daughters:
			iterate_nodes(daughter)

		find_blocks(node)
		


	blocks=iterate_nodes(root)
	handle.close()






def moving_window_recombination_detection(treeObject, prefix="gubbins"):
	
	seqlen=len(treeObject.node(treeObject.root).get_data().comment["sequence"])
	
	windowsize=int(float(seqlen)/1000)
	
	if windowsize<10:
		windowsize=10
	elif windowsize>1000:
		windowsize=1000
	
	
	max_distance=0
	for terminal in treeObject.get_terminals():
		distance=treeObject.distance(treeObject.root, terminal)
		if distance>max_distance:
			max_distance=distance
	
	data = treeObject.node(treeObject.root).get_data()
	
	data.branchlength=max_distance/100
	
	treeObject.node(treeObject.root).set_data(data)
	
	max_distance=max_distance+data.branchlength
	
	
	def ladderize_nodes(nodes,ladderize=None):
		"""Sorts node numbers according to the number of terminal nodes."""
		if ladderize in ['left','LEFT','right','RIGHT']:
			succnode_terminals=[(treeObject.count_terminals(node=n),n) for n in nodes]
			succnode_terminals.sort()
			if (ladderize=='right' or ladderize=='RIGHT'):
				succnode_terminals.reverse()
			if succnode_terminals:
				succnodes=zip(*succnode_terminals)[1]
			else:
				succnodes=[]
		else:
			succnodes=nodes
			succnodes.sort()
			return succnodes
	
	def get_node_colours(treeObject, ladderize=None):
		
		node=treeObject.root
		
		def get_node_colour(node, leftdist, rightdist, max_distance, num_nodes, node_num, nodecolours={}):
			node_num+=1
			#print node, (leftdist/max_distance)*255, (float(node_num)/num_nodes)*255, (rightdist/max_distance)*255, node_num, num_nodes,leftdist, rightdist, max_distance
			nodecolours[node]=((leftdist/max_distance)*255, (float(node_num)/num_nodes)*255, (rightdist/max_distance)*255)
			#nodecolours[node]=((leftdist/max_distance)*255, 0, (rightdist/max_distance)*255)
			if treeObject.node(node).succ:
	   			daughters=ladderize_nodes(treeObject.node(node).succ,ladderize=ladderize)
	   			daughters.reverse()
	   			
	   			for daughter in daughters:
	   			
					if daughter==daughters[0]:
						newdist=leftdist+treeObject.node(daughter).get_data().branchlength
						nodecolours, node_num=get_node_colour(daughter, newdist, rightdist, max_distance, num_nodes, node_num, nodecolours)
					else:
						newdist=rightdist+treeObject.node(daughter).get_data().branchlength
						nodecolours, node_num=get_node_colour(daughter, leftdist, newdist, max_distance, num_nodes, node_num, nodecolours)
						
					
					
			
			#colour stuff here :-S
			
			
			
			
			return nodecolours, node_num
		
		
		
		num_nodes=treeObject.count_terminals(node)*2
		
		#print max_distance, num_nodes
		
		nodecolours={}
		
		nodecolours, node_num=get_node_colour(node, 0, 0, max_distance, num_nodes, 0, nodecolours={})
		
		#print nodecolours
		
		return nodecolours
		
	
	
	
	
	def get_max_depth(treeObject, ladderize=None):
		node=treeObject.root
	
		def recurse(node, depth, right, left, max_depth, max_right, max_left, ladderize=None):
		
			if depth>max_depth:
				max_depth=depth
			if left>max_left:
				max_left=left
			if right>max_right:
				max_right=right
			
			if treeObject.node(node).succ:
	   			daughters=ladderize_nodes(treeObject.node(node).succ,ladderize=ladderize)
	   			daughters.reverse()
	   			for daughter in daughters:
	   				
		   			if daughter==daughters[0]:
		   				newdepth=depth+1
		   				newleft=left+1
						max_depth, max_right, max_left=recurse(daughter, newdepth, right, newleft, max_depth, max_right, max_left, ladderize=ladderize)
					else:
						newdepth=depth+1
						newright=right+1
						max_depth, max_right, max_left=recurse(daughter, newdepth, newright, left, max_depth, max_right, max_left, ladderize=ladderize)
					
			
			return max_depth, max_right, max_left
		
		
		max_depth, max_right, max_left=recurse(node, 0, 0, 0, 0, 0, 0, ladderize=ladderize)
		
		return max_depth, max_right, max_left
	
	
	def get_node_colours(treeObject, ladderize=None):
		
		node=treeObject.root
		
		max_depth, max_right, max_left=get_max_depth(treeObject)
		#print max_depth, max_right, max_left
		def get_node_colour(node, num_nodes, node_num, nodecolours={}):
			
			#print node, (leftdist/max_distance)*255, (float(node_num)/num_nodes)*255, (rightdist/max_distance)*255, node_num, num_nodes,leftdist, rightdist, max_distance
			#nodecolours[node]=((leftdist/max_distance)*255, (float(node_num)/num_nodes)*255, (rightdist/max_distance)*255)
			#nodecolours[node]=((leftdist/max_distance)*255, 255-((float(rightdist)/max_depth)*255), (rightdist/max_distance)*255)
			#nodecolours[node]=((float(leftdist)/max_left)*255, 255-((float(node_num)/num_nodes)*255), (float(rightdist)/max_right)*255)
			#nodecolours[node]=((float(node_num)/num_nodes)*255, 0, 255-((float(node_num)/num_nodes)*255))
			
			
			
			
			
			
			if treeObject.node(node).succ:
	   			daughters=ladderize_nodes(treeObject.node(node).succ,ladderize=ladderize)
	   			daughters.reverse()
	   			
	   			
	   			nodecolours, node_num=get_node_colour(daughters[0], num_nodes, node_num, nodecolours)
	   			nodeproportion=(float(node_num)/num_nodes)*1275
			
				red=510-nodeproportion
				blue=nodeproportion-510
				green=nodeproportion
	   			if red<-510:
					reddiff=510+red
					red=reddiff*-1
				elif red<0:
					red=0
				elif red>255:
					red=255
				if blue<0:
					blue=0
				elif blue>255:
					blue=255
				if green>255 and green<765:
					green=255
				elif green>765:
					greendiff=765-green
					green=255+greendiff
					if green<0:
						green=0
				
				
				#print red, green, blue
	   			
	   			if node==treeObject.root:
	   				nodecolours[node]=(0, 0, 0)
	   			else:
		   			nodecolours[node]=(red, green, blue)
	   			node_num+=1
				nodecolours, node_num=get_node_colour(daughters[1], num_nodes, node_num, nodecolours)
				
			else:
				nodeproportion=(float(node_num)/num_nodes)*1275
			
				red=510-nodeproportion
				blue=nodeproportion-510
				green=nodeproportion
				if red<-510:
					reddiff=510+red
					red=reddiff*-1
				elif red<0:
					red=0
				elif red>255:
					red=255
				if blue<0:
					blue=0
				elif blue>255:
					blue=255
				if green>255 and green<765:
					green=255
				elif green>765:
					greendiff=765-green
					green=255+greendiff
					if green<0:
						green=0
				
				
				#print red, green, blue
	   			
	   			nodecolours[node]=(red, green, blue)
				node_num+=1
			
			return nodecolours, node_num
		
		
		
		num_nodes=(treeObject.count_terminals(node)*2)-1
		
		#print max_distance, num_nodes
		
		nodecolours={}
		
		nodecolours, node_num=get_node_colour(node, num_nodes, 0, nodecolours={})
		
		#print nodecolours
		
		return nodecolours
	
	
	
	
		
		
		
	
	def print_node_diagram(treeObject, node, nodecolours, besthits):
	
		
	
		def add_coloured_track(node,track_number=1,ladderize=None):
	   		
			if treeObject.node(node).succ:
	   			succnodes=ladderize_nodes(treeObject.node(node).succ,ladderize=ladderize)
	   			succnodes.reverse()
		   		#for succnode in succnodes:
		   		track_number=add_coloured_track(succnodes[0],track_number,ladderize=ladderize)
	   			gd_track_for_features = gd_diagram.new_track(track_number, scale=0, height=1)
				gd_feature_set = gd_track_for_features.new_set()
		
				feature=SeqFeature(FeatureLocation(1,100), strand=1, type="colour_test")
				color = translator.int255_color(nodecolours[node])
				#print nodecolours[node]
				gd_feature_set.add_feature(feature, color=color, label=0)
	
				track_number+=1
		   		track_number=add_coloured_track(succnodes[1],track_number,ladderize=ladderize)
	   		else:
				gd_track_for_features = gd_diagram.new_track(track_number, scale=0, height=1)
				gd_feature_set = gd_track_for_features.new_set()
		
				feature=SeqFeature(FeatureLocation(1,100), strand=1, type="colour_test")
				color = translator.int255_color(nodecolours[node])
				#print nodecolours[node]
				#print color
				gd_feature_set.add_feature(feature, color=color, label=0)
	
				track_number+=1
	   
	   		return track_number
	   		
	   	translator = ColorTranslator()
	   	gd_diagram = GenomeDiagram.Diagram()
		track_number=1
	   	
		add_coloured_track(treeObject.root,track_number,ladderize=None)
	  
		gd_diagram.draw(format="linear", orientation="landscape", pagesize='A4', fragments=1)#, start=0, end=len(record))
		
		filename="test.pdf"
		
		gd_diagram.write(filename, "PDF")
	
	
	def count_diffs(node1, node2, start, end):

		seq1=treeObject.node(node1).get_data().comment["sequence"][start:end]

		seq2=treeObject.node(node2).get_data().comment["sequence"][start:end]
		numdiffs=0
		for x, ambiguity1 in enumerate(seq1):

			bases1=set(ambiguity_to_bases[ambiguity1])
			bases2=set(ambiguity_to_bases[seq2[x]])

			if "-" in bases1:
				bases1.remove("-")
			if "-" in bases2:
				bases2.remove("-")
			
			
			
			if len(bases1)>0 and len(bases2)>0 and len(bases1.intersection(bases2))==0:
				numdiffs+=1
				#print bases1, bases2, bases1.union(bases2)
		
		#print node1, node2, start, end, numdiffs
		return numdiffs
	



        def get_downstream_nodes(treeObject,node):


            def add_next_node(node, downstream_nodes=[]):

                daughters=treeObject.node(node).get_succ()

                for daughter in daughters:

                    downstream_nodes=add_next_node(daughter,downstream_nodes=downstream_nodes)

                downstream_nodes.append(node)

                return downstream_nodes

            downstream_nodes=add_next_node(node)

            return downstream_nodes

	
	
	
	def moving_window_recombination(nodea,nodeb, besthits={}):
		linked_nodes=treeObject.node(nodea).get_succ()+[treeObject.node(nodea).get_prev()]

                
		
		if not besthits.has_key(nodea):
				besthits[nodea]={}
		
		for x in range(0, seqlen, windowsize):
			
			hit=count_diffs(nodea, nodeb, x, x+windowsize)
			
			#print nodea, nodeb, x, hit
			
			if not besthits[nodea].has_key(x):
				besthits[nodea][x]=[nodeb, hit, x, x+windowsize]
			elif hit<besthits[nodea][x][1]:
				#print x, besthits[x], nodeb, hit
				besthits[nodea][x]=[nodeb, hit, x, x+windowsize]
			elif hit==besthits[nodea][x][1] and besthits[nodea][x][0] not in linked_nodes and nodeb in linked_nodes:
			
				#print x, besthits[x], nodeb, hit, linked_nodes
			
				besthits[nodea][x]=[nodeb, hit, x, x+windowsize]
				
#			else:
#				print x, besthits[x], nodeb, hit
			 
	
		return besthits
	
	
	def get_all_node_distances(nodea, nodeb, node_distances=[]):
	
		daughters=treeObject.node(nodeb).get_succ()
		downstream_nodes=get_downstream_nodes(treeObject, nodea)
		
		for daughter in daughters:
			
                    if daughter in downstream_nodes:
                        continue
                    node_distances=get_all_node_distances(nodea, daughter, node_distances)
		
                    node_distances.append([treeObject.distance(nodea, daughter),daughter])
		
		return node_distances
	
	
	
	def node_recombination(node, besthits={}):
		
		daughters=treeObject.node(node).get_succ()
		
			
		node_distances=[]
		
		node_distances=get_all_node_distances(node, treeObject.root, node_distances)
		node_distances.sort()

                besthits[node]={}
                
		#print node_distances
		#downstream_nodes=get_downstream_nodes(treeObject, node)
#		pairwise_comparison(daughter)
#		
#		besthits=node_recombination(node, besthits=besthits)
#		print node, besthits
		
		
#		daughters=treeObject.node(nodeb).get_succ()
#		
		for node_data in node_distances:
			daughter=node_data[1]
			
                        if node==daughter:# or daughter in downstream_nodes:
				continue
			
			besthits=moving_window_recombination(node,daughter, besthits)
			#node_recombination(node, nodeb=daughter)
			
				
		
	
			#print node, daughter, besthits
		
		return besthits
	
	
	
	
	def pairwise_comparison(node, total_nodes, node_count=0, besthits={}):
		
		daughtersnew=treeObject.node(node).get_succ()
		node_count=node_count+1
		
		print "%.0f%% complete\r" % (100*(float(node_count)/total_nodes)),
		sys.stdout.flush()
		
		for daughter in daughtersnew:
		
			besthits, node_count=pairwise_comparison(daughter, total_nodes, node_count=node_count,besthits=besthits)
#		

		besthits=node_recombination(node, besthits=besthits)
		#print node, besthits
		
		#linked_nodes=daughters+[treeObject.node(node).get_prev()]
		
#		for besthit in besthits.keys():
#			if not besthits[besthit][0] in linked_nodes:
#				print node, besthit, besthits[besthit]
		
	
		return besthits, node_count
	
	
	
	
	def print_recombination_tree_diagram(treeObject, node, nodecolours, besthits, prefix=""):
	
		depth=0
		
		#print (189.0/len(nodecolours.keys())), (189.0/len(nodecolours.keys()))/267.3
		
		vertical_line_scaling_factor=((189.0/len(nodecolours.keys()))/267.3)*350000
		
		font_size=((189.0/len(nodecolours.keys()))/0.3572)+2
		
		#print font_size
		
		#sys.exit()
	
		def add_coloured_track(node,track_number=1,ladderize=None, depth=0, prevfeatures=[], prev_move="none", node_depth=0):
	   		
	   		if not besthits.has_key(node):
	   			besthits[node]={0:[node,0, 0,seqlen]}
	   		
	   		if prev_move=="left":
	   			strand=1
	   		elif prev_move=="right":
	   			strand=-1
	   		else:
	   			strand=0
	   		
	   		#strand=0
	   		branchlength=treeObject.node(node).get_data().branchlength
	   		depthratio=((branchlength/max_distance)*1000000)+vertical_line_scaling_factor
			totaldepthratio=((depth/max_distance)*1000000)
	   		
	   			   		
			if treeObject.node(node).succ:
	   			succnodes=ladderize_nodes(treeObject.node(node).succ,ladderize=ladderize)
	   			succnodes.reverse()
		   		#for succnode in succnodes:

				newprevfeatures=prevfeatures[:]
#				newprevfeatures=[]
				for feature in newprevfeatures:
					if feature[1]==node:
						if feature[2]:
							feature[2]=False
						else:
							feature[2]=True
				
		   		newprevfeatures.append([SeqFeature(FeatureLocation(depthratio+totaldepthratio,depthratio+vertical_line_scaling_factor+totaldepthratio), strand=0, type="colour_test"), succnodes[0], True])
		   		
		   				   		
		   		track_number=add_coloured_track(succnodes[0],track_number,ladderize=ladderize, depth=depth+branchlength, prevfeatures=newprevfeatures, prev_move="right", node_depth=node_depth+1)
		   		
		   		
		   		
	   			gd_track_for_features = gd_diagram.new_track(track_number, scale=0, height=1)
				gd_feature_set = gd_track_for_features.new_set()
				
				#features=[]
				
				for feature in prevfeatures:
					if feature[2] or feature[1]==node:
						gd_feature_set.add_feature(feature[0], color=translator.int255_color(nodecolours[feature[1]]), label=0)
				
				

				for location in besthits[node].keys():
					if besthits[node][location][0]!=node:
						#print node, location, besthits[node][location]
						color = translator.int255_color(nodecolours[besthits[node][location][0]])
					else:
						color = translator.int255_color(nodecolours[node])
						#color = translator.int255_color((230,230,230))
					
					
					startposition=((float(besthits[node][location][2])/seqlen)*depthratio)+vertical_line_scaling_factor
					endposition=((float(besthits[node][location][3])/seqlen)*depthratio)+vertical_line_scaling_factor
					if (endposition-startposition)<vertical_line_scaling_factor:
						endposition=startposition+vertical_line_scaling_factor
					
					#print totaldepthratio
					feature=SeqFeature(FeatureLocation(startposition+totaldepthratio,endposition+totaldepthratio), strand=strand, type="colour_test")
					gd_feature_set.add_feature(feature, color=color, label=0)
				feature=SeqFeature(FeatureLocation(depthratio+totaldepthratio,depthratio+vertical_line_scaling_factor+totaldepthratio), strand=0)
				gd_feature_set.add_feature(feature, color=translator.int255_color(nodecolours[node]), label=0)
				
				#print nodecolours[node]
	
				track_number+=1
				
				newprevfeatures=prevfeatures[:]
#				newprevfeatures=[]
				for feature in newprevfeatures:
					if feature[1]==node:
						if feature[2]:
							feature[2]=False
						else:
							feature[2]=True
							
				
				
		   		newprevfeatures.append([SeqFeature(FeatureLocation(depthratio+totaldepthratio,depthratio+vertical_line_scaling_factor+totaldepthratio), strand=0, type="colour_test"), succnodes[1], False])
		   		track_number=add_coloured_track(succnodes[1],track_number,ladderize=ladderize, depth=depth+branchlength, prevfeatures=newprevfeatures, prev_move="left", node_depth=node_depth+1)
	   		else:
				gd_track_for_features = gd_diagram.new_track(track_number, scale=0, height=1)
				gd_feature_set = gd_track_for_features.new_set()
		
				features=[]
				
				for feature in prevfeatures:
					if feature[2] or feature[1]==node:
						gd_feature_set.add_feature(feature[0], color=translator.int255_color(nodecolours[feature[1]]), label=0)
				
				
				for location in besthits[node].keys():
					if besthits[node][location][0]!=node:
						#print node, location, besthits[node][location]
						color = translator.int255_color(nodecolours[besthits[node][location][0]])
					else:
						color = translator.int255_color(nodecolours[node])
						#color = translator.int255_color((230,230,230))
					
					startposition=((float(besthits[node][location][2])/seqlen)*depthratio)+vertical_line_scaling_factor
					endposition=((float(besthits[node][location][3])/seqlen)*depthratio)+vertical_line_scaling_factor
					if (endposition-startposition)<vertical_line_scaling_factor:
						endposition=startposition+vertical_line_scaling_factor
					
					print startposition, endposition, startposition+vertical_line_scaling_factor
					
					#print totaldepthratio
					feature=SeqFeature(FeatureLocation(startposition+totaldepthratio,endposition+totaldepthratio), strand=strand, type="colour_test")
					gd_feature_set.add_feature(feature, color=color, label=0)
					
					
				taxonname=treeObject.node(node).data.taxon
				feature=SeqFeature(FeatureLocation(depthratio+(2*vertical_line_scaling_factor)+totaldepthratio,depthratio+(2*vertical_line_scaling_factor)+totaldepthratio), strand=1)
				gd_feature_set.add_feature(feature, color=translator.int255_color((254,255,255)), label=1, label_size=font_size, label_color=translator.int255_color(nodecolours[node]), label_angle=180, label_position="start", strand=2, name=taxonname)	
				
				
				#print nodecolours[node]
	
				track_number+=1
	   
	   		return track_number
	   		
	   	translator = ColorTranslator()
	   	gd_diagram = GenomeDiagram.Diagram()
		track_number=1
	   	
		add_coloured_track(treeObject.root,track_number,ladderize=None)
	  
		gd_diagram.draw(format="linear", orientation="landscape", pagesize='A4', fragments=1)#, start=0, end=len(record))
		
		filename=prefix+"_tree.pdf"
		
		gd_diagram.write(filename, "PDF")
	
	
	
	
	def print_recombination_node_diagram(treeObject, node, nodecolours, besthits, prefix=""):
	
		depth=0
	
		def add_coloured_track(node,track_number=1,ladderize=None, depth=0):
	   		
			if treeObject.node(node).succ:
	   			succnodes=ladderize_nodes(treeObject.node(node).succ,ladderize=ladderize)
	   			succnodes.reverse()
		   		#for succnode in succnodes:
		   		
		   		track_number=add_coloured_track(succnodes[0],track_number,ladderize=ladderize, depth=depth+treeObject.node(node).get_data().branchlength)
	   			gd_track_for_features = gd_diagram.new_track(track_number, scale=0, height=1)
				gd_feature_set = gd_track_for_features.new_set()
				
				features=[]
				for location in besthits[node].keys():
					if besthits[node][location][0]!=node:
						#print node, location, besthits[node][location]
						color = translator.int255_color(nodecolours[besthits[node][location][0]])
					else:
						#color = translator.int255_color(nodecolours[node])
						color = translator.int255_color((230,230,230))
					
					startposition=besthits[node][location][2]
					endposition=besthits[node][location][3]
					#print totaldepthratio
					feature=SeqFeature(FeatureLocation(startposition,endposition), strand=1, type="colour_test")
					gd_feature_set.add_feature(feature, color=color, label=0)
				
				#print nodecolours[node]
	
				track_number+=1
		   		
		   		track_number=add_coloured_track(succnodes[1],track_number,ladderize=ladderize, depth=depth+treeObject.node(node).get_data().branchlength)
	   		else:
				gd_track_for_features = gd_diagram.new_track(track_number, scale=0, height=1)
				gd_feature_set = gd_track_for_features.new_set()
		
				features=[]
				for location in besthits[node].keys():
					if besthits[node][location][0]!=node:
						#print node, location, besthits[node][location]
						color = translator.int255_color(nodecolours[besthits[node][location][0]])
					else:
						#color = translator.int255_color(nodecolours[node])
						color = translator.int255_color((230,230,230))
					
					startposition=besthits[node][location][2]
					endposition=besthits[node][location][3]
					#print totaldepthratio
					feature=SeqFeature(FeatureLocation(startposition,endposition), strand=1, type="colour_test")
					gd_feature_set.add_feature(feature, color=color, label=0)
				
				#print nodecolours[node]
	
				track_number+=1
	   
	   		return track_number
	   		
	   	translator = ColorTranslator()
	   	gd_diagram = GenomeDiagram.Diagram()
		track_number=1
	   	
		add_coloured_track(treeObject.root,track_number,ladderize=None)
	  
		gd_diagram.draw(format="linear", orientation="landscape", pagesize='A4', fragments=1)#, start=0, end=len(record))
		
		filename=prefix+"_recombination_linear.pdf"
		
		gd_diagram.write(filename, "PDF")
	
	

	def print_recombinations_to_tab(treeObject, besthits, handle):

            root=treeObject.root

            def print_node_recombinations(node):

                daughtersnew=treeObject.node(node).get_succ()

                for daughter in daughtersnew:
                    print_node_recombinations(daughter)

                for location in besthits[node].keys():
                    if besthits[node][location][0]==node:
                        continue
                    startposition=besthits[node][location][2]
                    endposition=besthits[node][location][3]
                    fromnode=besthits[node][location][0]
                    fromprev=treeObject.node(fromnode).get_prev()
                    if fromprev==treeObject.root:
                        fromprev="root"
                    nodeprev=treeObject.node(node).get_prev()
                    if nodeprev==treeObject.root:
                        nodeprev="root"
                    if treeObject.is_terminal(node):
                        nodename=treeObject.node(node).data.taxon
                    else:
                        nodename=str(node)
                    if treeObject.is_terminal(fromnode):
                        fromnodename=treeObject.node(fromnode).data.taxon
                    else:
                        fromnodename=str(fromnode)
                    nonrecombscore=besthits[node][location][-1][0]
                    recombscore=besthits[node][location][-1][1]
                    
                    print >> handle, "FT   recombination   "+str(startposition)+".."+str(endposition)
                    print >> handle, "FT                   /colour=3"
                    print >> handle, 'FT                   /recipient_branch='+str(nodeprev)+"->"+nodename
                    print >> handle, 'FT                   /donor_branch='+str(fromprev)+"->"+fromnodename
                    print >> handle, "FT                   /original_branch_SNPs="+str(nonrecombscore)
                    print >> handle, "FT                   /recombination_branch_SNPs="+str(recombscore)
                    print >> handle, "FT                   /improvement="+str(nonrecombscore-recombscore)
	
            
            print_node_recombinations(root)
	
	
	node=treeObject.root
	#besthits={}

	
	nodecolours=get_node_colours(treeObject)
	
	#print nodecolours
	
	
	output=open(prefix+"_recombination_key.tre","w")
	
	print >> output, tree_to_figtree_string(treeObject, False, False, False, False, node_colours=nodecolours)
	
	output.close()
	
	
	print_recombination_tree_diagram(treeObject, node, nodecolours,{}, prefix=prefix)

	#print_node_diagram(treeObject, treeObject, nodecolours,besthits)
	besthits, node_count=pairwise_comparison(node, len(treeObject.get_terminals())*2)
	
	for key in besthits.keys():
		locations=besthits[key].keys()
		locations.sort()
		
		linked_nodes=treeObject.node(key).get_succ()+[treeObject.node(key).get_prev()]
		
		lastlocationkey=-1
		lastbesthit=-1
		
		for locationkey in locations:
		
			if besthits[key][locationkey][0] in linked_nodes or count_diffs(key, treeObject.node(key).get_prev(), besthits[key][locationkey][2], besthits[key][locationkey][3])<=besthits[key][locationkey][1]:
				besthits[key][locationkey][0]=key

		
			if besthits[key][locationkey][0]==lastbesthit:
				besthits[key][locationkey][2]=besthits[key][lastlocationkey][2]
				besthits[key][locationkey][1]+=besthits[key][lastlocationkey][1]
				del besthits[key][lastlocationkey]
			lastlocationkey=locationkey
			lastbesthit=besthits[key][locationkey][0]
			if besthits[key][locationkey][3]>seqlen:
				besthits[key][locationkey][3]=seqlen
		
		
		locations=besthits[key].keys()
		locations.sort()
		
		todelete=[]
		
		for x, locationkey in enumerate(locations):
			if besthits[key][locationkey][0]!=key:
				y=x+1
				endofblock=False
				while y<len(locations) and besthits[key][locations[y]][0]==key:
					if count_diffs(key, besthits[key][locations[y]][0], besthits[key][locations[y]][2], besthits[key][locations[y]][3])>besthits[key][locations[y]][1]:
						endofblock=True
						break
					y=y+1
				
				if y==len(locations) or endofblock:
					continue
				
				if besthits[key][locationkey][0]==besthits[key][locations[y]][0] and count_diffs(key, besthits[key][locations[y]][0], besthits[key][locationkey][2], besthits[key][locations[y]][3])<count_diffs(key, treeObject.node(key).get_prev(), besthits[key][locationkey][2], besthits[key][locations[y]][3]):
					besthits[key][locations[y]][2]=besthits[key][locationkey][2]
					for z in range(x,y):
						
						todelete.append(locations[z])
				
				elif count_diffs(key, besthits[key][locationkey][0], besthits[key][locations[y]][2], besthits[key][locations[y]][3])<=count_diffs(key, besthits[key][locations[y]][0], besthits[key][locations[y]][2], besthits[key][locations[y]][3]) and count_diffs(key, besthits[key][locationkey][0], besthits[key][locationkey][2], besthits[key][locations[y]][3])<count_diffs(key, treeObject.node(key).get_prev(), besthits[key][locationkey][2], besthits[key][locations[y]][3]):
					besthits[key][locations[y]][0]=besthits[key][locationkey][0]
					besthits[key][locations[y]][2]=besthits[key][locationkey][2]
					for z in range(x,y):
						todelete.append(locations[z])
						
				elif count_diffs(key, besthits[key][locations[y]][0], besthits[key][locationkey][2], besthits[key][locations[y]][3])<count_diffs(key, treeObject.node(key).get_prev(), besthits[key][locationkey][2], besthits[key][locations[y]][3]):
					besthits[key][locations[y]][2]=besthits[key][locationkey][2]
					for z in range(x,y):
						todelete.append(locations[z])
					

				
				
				
		for location in todelete:
			del besthits[key][location]
				
		
		
		
		for locationkey in besthits[key].keys():
			if besthits[key][locationkey][0]==key:
				continue
			currvscurrprev=count_diffs(key, treeObject.node(key).get_prev(), besthits[key][locationkey][2], besthits[key][locationkey][3])
			currvsaltprev=count_diffs(key, treeObject.node(besthits[key][locationkey][0]).get_prev(), besthits[key][locationkey][2], besthits[key][locationkey][3])
			altvscurrprev=count_diffs(besthits[key][locationkey][0], treeObject.node(key).get_prev(), besthits[key][locationkey][2], besthits[key][locationkey][3])
			altvsaltprev=count_diffs(besthits[key][locationkey][0], treeObject.node(besthits[key][locationkey][0]).get_prev(), besthits[key][locationkey][2], besthits[key][locationkey][3])
		
			#print "currvscurrprev", currvscurrprev, "currvsaltprev", currvsaltprev
			#print "altvscurrprev", altvscurrprev, "altvsaltprev", altvsaltprev
			
		
		
			if currvscurrprev<currvsaltprev and altvscurrprev<altvsaltprev:
                            #print "here"
                            besthits[key][locationkey][0]=key
                        else:
                            currvsalt=count_diffs(key, besthits[key][locationkey][0], besthits[key][locationkey][2], besthits[key][locationkey][3])
                            besthits[key][locationkey].append([currvscurrprev, currvsalt])
                        
                            
		
	
	print_recombination_node_diagram(treeObject, node, nodecolours,besthits, prefix=prefix)
	print_recombination_tree_diagram(treeObject, node, nodecolours,besthits, prefix=prefix+"_recombination")
        handle=open(prefix+"_recombinations.tab", "w")
        print_recombinations_to_tab(treeObject, besthits, handle)
        handle.close()












#def print_blocks_to_tab(treeObject, node, blocks, handle):
#	
#	for block in blocks:
#		node_seq=treeObject.node(node).get_data().comment["sequence"][block["start"]: block["end"]+1]
#		donorlist=[]
#		#count the number of differences to the ancestor of the current node
#		mindiffs=count_diffs_for_seqs(node_seq, treeObject.node(treeObject.node(node).get_prev()).get_data().comment["sequence"][block["start"]: block["end"]+1])
#		node_prev_count=mindiffs
#		
#		
#		for donor in block["donors"]:
#			try:
#				donor_prev=treeObject.node(donor).get_prev()
#				donor_seq=get_consensus(treeObject.node(donor).get_data().comment["sequence"][block["start"]: block["end"]+1], treeObject.node(donor_prev).get_data().comment["sequence"][block["start"]: block["end"]+1])
#			except:
#				donor_seq=treeObject.node(node).get_data().comment["sequence"][block["start"]: block["end"]+1]
#		
#			diffs=count_diffs_for_seqs(node_seq, donor_seq)
#			if treeObject.is_terminal(donor):
#				donorname=treeObject.node(donor).data.taxon
#			else:
#				donorname=donor
#			if diffs<mindiffs:
#				donorlist=[]
#				colour=str(int(treeObject.node(donor).data.comment["colour"][0]))+" "+str(int(treeObject.node(donor).data.comment["colour"][1]))+" "+str(int(treeObject.node(donor).data.comment["colour"][2]))
#				donorlist.append(str(donorname))
#				mindiffs=diffs
#			elif diffs==mindiffs:
#				colour="1"
#				donorlist.append(str(donorname))
#		
#		#if no possible donors have been added to the list, 
#		if len(donorlist)==0:
#			continue
#		
#		downstreamnamelist=treeObject.get_taxa(node)
#		
#		print >> handle, "FT   misc_feature    "+str(block["start"]+1)+".."+str(block["end"]+1)
#		print >> handle, "FT                   /node="+str(node)
#
#		print >> handle, 'FT                   /possible_donors="'+', '.join(donorlist)+'"'
#			
#		print >> handle, 'FT                   /neg_log_likelihood='+str(block["ll"])
#		print >> handle, 'FT                   /shared_homoplasy_count='+str(block["snpcount"])
#		print >> handle, 'FT                   /node_vs_donor_SNP_count='+str(mindiffs)
#		print >> handle, 'FT                   /node_vs_parent_SNP_count='+str(node_prev_count)
#		print >> handle, 'FT                   /improvement='+str(node_prev_count-mindiffs)
#		print >> handle, 'FT                   /pvalue='+str(block["p"])
#		print >> handle, 'FT                   /taxa="'+', '.join(downstreamnamelist)+'"'
#		print >> handle, 'FT                   /colour='+colour
#		
##		nodeproportion=(float(block["p"])/0.05)*255
##		red=int(255-nodeproportion)
##		if red>255:
##			red=255
##		blue=int(nodeproportion)
##		if blue<0:
##			blue=0
##		
##		colourstring=str(red)+" 0 "+str(blue)
##		
##		print >> handle, 'FT                   /colour='+colourstring




def randomise_binsnps(binsnps):

	new_binsnps=binsnps[:]
	shuffle(new_binsnps)
	new_snpposns=[]
	new_nongapposns=[]
	for x in new_binsnps:
		
		#if node_seq[x] in missing_data_and_gaps or daughter_seq[x] in missing_data:
		if x==0:
			new_nongapposns.append(x)
		elif x==1:
			new_nongapposns.append(x)
			new_snpposns.append(x)
			

	return new_binsnps, new_snpposns, new_nongapposns



def detect_homoplasy_clusters_using_moving_windows(treeObject, binsnps, snpposns, binsnpposns, nongapposns, node, donor_list, handle):
	
	print "Node", node, "...",
	sys.stdout.flush()
	if len(binsnps)!=len(donor_list) or len(snpposns)!=len(donor_list) or len(nongapposns)!=len(donor_list):
		return
	minsnps=3
	Final_blocks=[]
	added=True
	totalsnps=[]
	lennogaps=[]
	oldtotalsnps=[]
	for y in range(0,len(binsnps)):
		totalsnps.append(len(snpposns[y]))
		lennogaps.append(len(nongapposns[y]))
		oldtotalsnps.append(0)
	
	
	while added:
		blocks=[]
		
		for x, donor in enumerate(donor_list):
			donor_blocks=[]
			donor_blocks=detect_all_clusters_using_moving_windows(treeObject, binsnps[x], snpposns[x], nongapposns[x], node, donor)
			

#			if len(donor_blocks)>0:
#				donor_blocks.sort()
#				pvalue=100.0
#				for randomisation in range(0,100):
#					new_binsnps, new_snpposns, new_nongapposns=randomise_binsnps(binsnps[x])
#					temp_blocks=detect_all_clusters_using_moving_windows(treeObject, new_binsnps, new_snpposns, new_nongapposns, node, donor)
#					if len(temp_blocks)>0:
#						temp_blocks.sort()
#						print donor_blocks[0], temp_blocks[0][0]
#						if donor_blocks[0][0]<temp_blocks[0][0]:
#							pvalue-=1
#					else:
#						pvalue-=1
#				if pvalue>0:
#					print pvalue
#					pvalue=pvalue/100
#					print pvalue
			
			for y in range(0,len(donor_blocks)):
				donor_blocks[y].append(donor)
				donor_blocks[y].append(x)
				
			blocks=blocks+donor_blocks
			
	#		if len(donor_blocks)>0:
	#			print donor, len(donor_blocks), len(blocks)
		blocks.sort()
		#print blocks
		added=False
		if len(blocks)>0:
			blocks.sort()			
			#print blocks[0]
			snpcount=0
			for y in range(0,len(binsnps)):
				oldtotalsnps[y]=int(totalsnps[y])
				#oldlennogaps[y]=lennogaps[y]
			#print blocks[0][0], blocks[0][1], blocks[0][2], blocks[0][3], blocks[0][4], len(binsnps), len(binsnps[blocks[0][4]])
			for x, snp in enumerate(binsnps[blocks[0][4]][blocks[0][1]:blocks[0][2]+1]):
				if snp==1:
					snpcount+=1
					for y in range(0,len(binsnps)):
						if binsnps[y][blocks[0][1]+x]==1:
							binsnps[y][blocks[0][1]+x]=0
							#totalsnps[y]-=1
							snpposns[y].remove(binsnpposns[y][blocks[0][1]+x])
							
				#lennogaps[blocks[0][3]]-=1
				
			for y in range(0,len(binsnps)):
				totalsnps[y]=len(snpposns[y])
				#lennogaps[y].append(len(nongapposns[y]))
				
			if snpcount>=minsnps:
				numgaps=0
				#print blocks[0][0], blocks[0][1], blocks[0][2], blocks[0][3], len(binsnps), len(binsnps[blocks[0][3]])
				for x in binsnps[blocks[0][4]][blocks[0][1]:blocks[0][2]+1]:
					if x==2:
						numgaps+=1
				
				blocklen=(((blocks[0][2]+1)-blocks[0][1])-numgaps)
				x=0
				pvalue=0.0
				while x<snpcount:
				
					part1=reduce_factorial(blocklen,x)-reduce_factorial(x,x)
					part2=math.log((float(oldtotalsnps[blocks[0][4]])/lennogaps[blocks[0][4]]),10)*x
					part3=math.log((1.0-(float(oldtotalsnps[blocks[0][4]])/lennogaps[blocks[0][4]])),10)*(blocklen-x)
				
					logthing=part1 + part2 + part3
					
					pvalue+=10**logthing
					x+=1
				pvalue=1.0-round(pvalue,10)
				pvaluethreshold=(0.05/float(lennogaps[blocks[0][4]]))
				#print blocklen, pvaluethreshold, snpcount, pvalue, oldtotalsnps, totalsnps
#				if pvalue<pvaluethreshold:
#					donors=set()
#					for block in blocks:
#						if block[0]==blocks[0][0] and block[1]==blocks[0][1] and block[2]==blocks[0][2]:
#							donors.add(block[3])
#						else:
#							break
#					if not treeObject.node(node).get_prev() in donors:	
#						Final_blocks.append({"start":blocks[0][1], "end":blocks[0][2], "ll":blocks[0][0], "donors":donors, "snpcount": snpcount, "p":pvalue})
#					added=True
#				else:
#					print "here"
				donors=set()
				for block in blocks:
					#if block[0]==blocks[0][0] and block[1]==blocks[0][1] and block[2]==blocks[0][2]:
					if block[1]==blocks[0][1] and block[2]==blocks[0][2]:
						donors.add(block[3])
					else:
						break
				if not treeObject.node(node).get_prev() in donors:
					Final_blocks.append({"start":blocks[0][1], "end":blocks[0][2], "ll":blocks[0][0], "donors":donors, "snpcount": snpcount, "p":pvalue})
				if len(blocks)>1:
					added=True
		
	print "Found", len(Final_blocks), "homoplasy block(s)"
	sys.stdout.flush()
	print_blocks_to_tab(treeObject, node, Final_blocks, handle)




def make_binsnps_for_branch(treeObject, node, daughter, locations=[]):
	
	node_seq=treeObject.node(node).get_data().comment["sequence"]
	daughter_seq=treeObject.node(daughter).get_data().comment["sequence"]
	
	binsnps=[0]*len(node_seq)
	snpposns=[]
	nongapposns=range(0,len(node_seq))
	if locations==[]:
		locations=range(0,len(node_seq))
		
	for x in locations:
		if node_seq[x] in missing_data_and_gaps or daughter_seq[x] in missing_data:
			binsnps.append(2)
		elif node_seq[x]!=daughter_seq[x]:
			nongapposns.append(x)
			binsnps.append(1)
			snpposns.append(x)
		else:
			binsnps.append(0)
			nongapposns.append(x)
	
	return binsnps, snpposns, nongapposns
	

def make_homoplasy_binsnps_for_branch(treeObject, node, locations=[]):
	missing_set=set(["N", "?"])
	missing_and_gaps_set=set(["N", "?", "-"])
	potential_donors=get_nodes_not_downstream(treeObject, node)
	#print get_downstream_nodes(treeObject, node)
	#print potential_donors
	
	node_seq=treeObject.node(node).get_data().comment["sequence"]
	if treeObject.node(node).get_data().comment.has_key("SNP_locations"):
		SNPlocations=treeObject.node(node).get_data().comment["SNP_locations"]
	else:	
		SNPlocations={}
	
	binsnps=[]
	snpposns=[]
	nongapposns=[]
	binsnpposns=[]
	
	#print potential_donors, node
	
	for y, donor in enumerate(potential_donors):
		binsnps.append([0]*len(node_seq))
		snpposns.append([])
		binsnpposns.append({})
		nongaptemp=set(range(0,len(node_seq)))
		daughter_seq=treeObject.node(donor).get_data().comment["sequence"]
		
		if locations==[]:
			locations=range(0,len(node_seq))
		gapcount=0
		for x in locations:
			
			#if node_seq[x] in missing_data_and_gaps or daughter_seq[x] in missing_data:
			if node_seq[x] in missing_and_gaps_set or daughter_seq[x] in missing_set:
				binsnps[y][x]=2
				nongaptemp.remove(x)
				gapcount+=1
			elif SNPlocations.has_key(x) and SNPlocations[x].homoplasy and node_seq[x]==daughter_seq[x]:
				binsnps[y][x]=1
				snpposns[y].append(x-gapcount)
				binsnpposns[y][x]=x-gapcount
			else:
				binsnps[y][x]=0
		nongapposns.append(list(nongaptemp))
		nongapposns[y].sort()
		
			
	return binsnps, snpposns, binsnpposns, nongapposns, potential_donors



def make_homoplasy_binsnps_for_branch_new(treeObject, node, locations=[]):
	missing_set=set(["N", "?"])
	missing_and_gaps_set=set(["N", "?", "-"])
	potential_donors=get_nodes_not_downstream(treeObject, node)
	#print get_downstream_nodes(treeObject, node)
	#print potential_donors
	
	node_seq=treeObject.node(node).get_data().comment["sequence"]
	if treeObject.node(node).get_data().comment.has_key("SNP_locations"):
		SNPlocations=treeObject.node(node).get_data().comment["SNP_locations"]
	else:	
		SNPlocations={}
	
	binsnps=[]
	snpposns=[]
	nongapposns=[]
	binsnpposns=[]
	finaldonors=[]
	
	#print potential_donors, node
	
	for y, donor in enumerate(potential_donors):
		binsnps.append([0]*len(node_seq))
		snpposns.append([])
		binsnpposns.append({})
		nongaptemp=set(range(0,len(node_seq)))
		daughter_seq=treeObject.node(donor).get_data().comment["sequence"]
		
		if locations==[]:
			locations=range(0,len(node_seq))
		gapcount=0
		for x in locations:
			
			#if node_seq[x] in missing_data_and_gaps or daughter_seq[x] in missing_data:
			if node_seq[x] in missing_and_gaps_set or daughter_seq[x] in missing_set:
				binsnps[y][x]=2
				nongaptemp.remove(x)
				gapcount+=1
			elif SNPlocations.has_key(x) and SNPlocations[x].homoplasy and node_seq[x]==daughter_seq[x]:
				binsnps[y][x]=1
				snpposns[y].append(x-gapcount)
				binsnpposns[y][x]=x-gapcount
			else:
				binsnps[y][x]=0
		nongapposns.append(list(nongaptemp))
		nongapposns[y].sort()
		if len(snpposns[y])<3:
			del binsnps[-1]
			del snpposns[-1]
			del binsnpposns[-1]
			del nongaptemp[-1]
			
		else:
			finaldonors.append(donor)
			
	return binsnps, snpposns, binsnpposns, nongapposns, finaldonors

def find_clusters_on_branches(treeObject, prefix="MW", homoplasy=False, locations=[]):
	
	def find_clusters_on_branch(treeObject, node, handle, homoplasy=False):	
		
		daughters=treeObject.node(node).get_succ()
		for daughter in daughters:
			find_clusters_on_branch(treeObject, daughter, handle, homoplasy=homoplasy)
			
			if not homoplasy:
				binsnps, snpposns, nongapposns=make_binsnps_for_branch(treeObject, node, daughter)
				detect_clusters_using_moving_windows(treeObject, binsnps, snpposns, nongapposns, node, daughter)
			
		if homoplasy:
			#print node
			#if node==12:
			binsnps, snpposns, binsnpposns, nongapposns, donor_list=make_homoplasy_binsnps_for_branch(treeObject, node, locations=locations)
			
			detect_homoplasy_clusters_using_moving_windows(treeObject, binsnps, snpposns, binsnpposns, nongapposns, node, donor_list, handle)
	
	
	
	#print nodecolours
	

	handle=open(prefix+"_recombination_key.tre","w")
	
	#print nodecolours
	print >> handle, tree_to_figtree_string(treeObject, False, False, False, False)
	
	handle.close()
	
	handle=open(prefix+"_recombination_blocks.tab","w")	
	find_clusters_on_branch(treeObject, treeObject.root, handle, homoplasy=homoplasy)
	
	handle.close()
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	











#
#
#def print_blocks_to_tab(treeObject, blocks, handle):
#	
#	for block in blocks:
#		node=block["recipient"]
#		
#		colour=str(int(treeObject.node(block["common_ancestor"]).data.comment["colour"][0]))+" "+str(int(treeObject.node(block["common_ancestor"]).data.comment["colour"][1]))+" "+str(int(treeObject.node(block["common_ancestor"]).data.comment["colour"][2]))
#		
#		donorlist=[]
#		for donor in block["donors"]:
#			if treeObject.is_terminal(donor):
#				donorname=treeObject.node(donor).data.taxon
#			else:
#				donorname=donor
#			donorlist.append(str(donorname))
#		
#		downstreamnamelist=treeObject.get_taxa(node)
#		
#		if treeObject.is_terminal(node):
#			nodename=treeObject.node(node).data.taxon
#		else:
#			nodename=node
#		
#		if treeObject.is_terminal(block["common_ancestor"]):
#			ancestor=treeObject.node(block["common_ancestor"]).data.taxon
#		else:
#			ancestor=block["common_ancestor"]
#		
#		print >> handle, "FT   misc_feature    "+str(block["start"]+1)+".."+str(block["end"]+1)
#		print >> handle, "FT                   /node="+str(nodename)
#		print >> handle, 'FT                   /possible_donors="'+', '.join(donorlist)+'"'
#		print >> handle, "FT                   /donor_common_ancestor="+str(ancestor)
#		print >> handle, 'FT                   /rank='+str(block["removal_round"])
#		print >> handle, 'FT                   /neg_log_likelihood='+str(block["ll"])
#		print >> handle, 'FT                   /recombined_snps='+str(block["snpcount"])	
#		print >> handle, 'FT                   /pvalue='+str(block["p"])
#		print >> handle, 'FT                   /taxa="'+', '.join(downstreamnamelist)+'"'
#		print >> handle, 'FT                   /colour='+colour
#		
#
#
#
#def get_N_and_C(snpposns, lennogaps):
#	N=0.0
#	C=0.0
#	for x in binsnps:
#		if x==0:
#			N+=1
#		elif x==1:
#			C+=1
#			N+=1
#	return N, C
#
#
#
#def get_block_likelihood(n, c, N, C):
#
#	n=float(n)
#	c=float(c)
##	for x in snpposns:
##		if x>=start and x<=end:
##			c+=1
#
#	#print c, n, C, N
#	part1=math.log((c/n),10)*c
#	if n-c==0:
#		part2=0
#	else:
#		part2=math.log((((n-c)/n)),10)*(n-c)
#	if C-c==0:
#		part3=0
#	else:
#		part3=math.log((((C-c)/(N-n))),10)*(C-c)
#	if ((N-n)-(C-c))==0:
#		part4=0
#	else:
#		part4=math.log(((((N-n)-(C-c))/(N-n))),10)*((N-n)-(C-c))
#	
#	likelihood=(part1+part2+part3+part4)*-1
#	
#	#print start, end, c, n, C, N, likelihood
#	#print likelihood
#	
#	return likelihood
#
#
#
#
#
#def reduce_factorial(l,i):
#	
#	
#	if l==i and l<1000:
#		return math.log(math.factorial(l),10)
#	
#	
#	factorial=math.log(1.0,10)
#	
#	
#	for x in range(int(l)-(int(i)-1),int(l)+1):
#		#print x, factorial
#		factorial=factorial+math.log(x,10)
#	
#	
#	return factorial
#	
#	
#
#def refine_blocks(snpposns, windowcounts, cutoff, lennogaps, minsnps, N, C):
#
#	tempblocks=[]
#	blockstart=0
#	inblock=False
#
#	x=0
#	y=0
#	
#	while x<len(windowcounts):
#	#for x, pvalue in enumerate(pvalues):
#		#if count>0:
#		#	print >> output, nongapposns[x]+1, windowcounts[x], X2[x], pvalues[x]
#		value=windowcounts[x]
#
#		
#		#print x, pvalue, inblock
#		
##		if value > cutoff:
##			print x, value
#		
#		if value>cutoff and not inblock:
#			
#			blockstart=x+1
#			inblock=True
#		elif value<=cutoff and inblock:
#				
#			tempblocks.append([0.0,blockstart,x+1])
#			inblock=False
#	
#		x=x+1
#		
#	if inblock:
#		tempblocks.append([0.0,blockstart,len(windowcounts)])
#
#	
#	#print len(binsnps), nongapposns[-1], len(windowcounts)
#	
#	#Trim blocks using likelihood
#	
#	
#	#C=len(snpposns)
#	#N=lennogaps
#	
#	#N,C=get_N_and_C(binsnps)
#	
#	newblocks=[]
#	
#	for block in tempblocks:
#		
#		
#		#trim to first and last SNPs in block
#		start=int(block[1])
#		end=int(block[2])
#		
#		x=0
#		
#		while x<(len(snpposns)-1) and snpposns[x]<start:
#			x+=1
#			
#		start=snpposns[x]
#		snpposnstart=x			
#		
#		
#		x=len(snpposns)-1
#		
#		while x>0 and snpposns[x]>end:
#			x-=1
#			
#		end=snpposns[x]
#		snpposnend=x
#		
#
#		if start>end:
#			continue
#		
#		old_like=get_block_likelihood((end+1)-start, (snpposnend+1)-snpposnstart, N, C)
#		
#		#print "initial likelihood=", old_like, "start=", start, "end=", end, snpposnstart, snpposnend
#		
#		newstart=start
#		oldstart=start
#		newsnpposnstart=snpposnstart
#		
#		if snpposnstart+1<(snpposnend+1)-minsnps:
#			for x, snpposnloc in enumerate(snpposns[snpposnstart+1: (snpposnend+1)-minsnps]):
#				
#				new_like=get_block_likelihood((end+1)-snpposnloc, (snpposnend+1)-(snpposnstart+x), N, C)
#					
#				if new_like>old_like:
#					start=newstart
#					break
#				else:
#					newstart=snpposnloc
#					newsnpposnstart=snpposnstart+x
#					old_like=new_like
#		
#		start=newstart
#		snpposnstart=newsnpposnstart
#		
#		
#		if start==oldstart and snpposnstart>0:
#			newstart=start
#			
#			for x, snpposnloc  in enumerate( snpposns[snpposnstart-1::-1]):
#				
#				new_like=get_block_likelihood((end+1)-snpposnloc, (snpposnend+1)-(snpposnstart-x), N, C)
#					
#				if new_like>old_like:
#					start=newstart
#					break
#				else:
#					newstart=snpposnloc
#					newsnpposnstart=snpposnstart-x
#					old_like=new_like
#		
#		start=newstart
#		snpposnstart=newsnpposnstart
#		
#		
#		newsnpposnend=snpposnend
#		newend=end
#		oldend=end
#		if snpposnend>minsnps and (snpposnend-1)>(snpposnstart+minsnps):
#			for x, snpposnloc in enumerate( snpposns[ snpposnend-1: snpposnstart+minsnps: -1]):
#				
#				new_like=get_block_likelihood((snpposnloc+1)-start, (snpposnend+1-x)-snpposnstart, N, C)
#				
#				if new_like>old_like:
#					end=newend
#					break
#				else:
#					newend=snpposnloc
#					newsnpposnend=snpposnend-x
#					old_like=new_like
#		
#		end=newend
#		snpposnend=newsnpposnend
#		
#		if end==oldend and snpposnend+1<len(snpposns):
#			newend=end
#			for x, snpposnloc in enumerate(snpposns[ snpposnend+1:]):
#				
#				new_like=get_block_likelihood((snpposnloc+1)-start, (snpposnend+1+x)-snpposnstart, N, C)
#				
#				if new_like>old_like:
#					end=newend
#					break
#				else:
#					newend=snpposnloc
#					newsnpposnend=snpposnend+x
#					old_like=new_like
#		
#		end=newend
#		
#		snpposnend=newsnpposnend
#		likelihood=old_like
#		
#		#print "new likelihood=", old_like, "start=", start, "end=", end
#		block[0]=old_like
#		block[1]=start
#		block[2]=end
#		snpcount=0
#	
#
#
#		snpcount=(snpposnend+1)-snpposnstart
#		if snpcount>=minsnps:
#			newblocks.append([likelihood, start, end, snpposnstart, snpposnend])
#
#	
#	return newblocks
#
#
#
#
#
#
#
#
#################################################################
## Function to detect recombination regions using moving window #
#################################################################
#
#
#def detect_blocks_using_moving_windows_new(treeObject, snpposns, lennogaps, minsnps, N, C):
#	
#	totalsnps=float(len(snpposns))
#	
#	if totalsnps<minsnps:
#		return []
#	
#	windowcounts=[0]*(int(lennogaps))
#	
#	window=int(float(lennogaps)/(totalsnps/10))
#	
#	if window<100:
#		window=100
#	elif window>lennogaps:
#		window=lennogaps/2
#	elif window>10000:
#		window=10000
#	
#	
#	for position in snpposns:
#		
#		y=position-(window/2)
#		curposn=int(y)
#		while (y+window)>curposn:
#			if curposn<0:
#				actualposn=lennogaps+curposn
#			elif curposn>(lennogaps-1):
#				actualposn=curposn-lennogaps
#			else:
#				actualposn=curposn
#			
#			windowcounts[actualposn]+=1
#			curposn+=1
#
#	threshold=1-(0.05/(float(lennogaps)/(window/10)))
#	cutoff=0
#	pvalue=0.0
#	while pvalue<=threshold:
#		part1=reduce_factorial(window,cutoff)-reduce_factorial(cutoff,cutoff)
#		part2=math.log((float(totalsnps)/lennogaps),10)*cutoff
#		part3=math.log((1.0-(float(totalsnps)/lennogaps)),10)*(window-cutoff)
#		
#		logthing=part1 + part2 + part3
#		
#		pvalue+=10**logthing
#		
#		cutoff+=1
#		
#		
#	cutoff-=1
#	
#	newblocks=[]
#	if cutoff<=totalsnps and cutoff>=minsnps:
#		newblocks=refine_blocks(snpposns, windowcounts, cutoff, lennogaps, minsnps, N, C)
#	
#	return newblocks


#def detect_homoplasy_clusters_using_moving_windows_new(treeObject, homoplasyposns, homoplasyposntonogapposn, nogapposntohomoplasyposn, alignmentlengths, handle, minsnps):
#	
#
#
#	def remove_downstream_donors(recipientnode, donornode, alignmentbase):
#
#		daughters=treeObject.node(recipientnode).get_succ()
#		
#		#print daughters
#		for daughter in daughters:
#			if not treeObject.node(daughter).get_data().comment.has_key("SNP_locations") or not treeObject.node(daughter).get_data().comment["SNP_locations"].has_key(alignmentbase):
#				remove_downstream_donors(daughter,donornode,alignmentbase)
#	
#
#		if homoplasyposntonogapposn.has_key(donornode) and homoplasyposntonogapposn[donornode].has_key(recipientnode) and homoplasyposntonogapposn[donornode][recipientnode].has_key(alignmentbase):
#			translatedsnplocation=homoplasyposntonogapposn[donornode][recipientnode][alignmentbase]
#						
#			homoplasyposns[donornode][recipientnode].remove(translatedsnplocation)
#			#print "removing donor ", donornode, recipientnode, translatedsnplocation
#			del homoplasyposntonogapposn[donornode][recipientnode][alignmentbase]
#			del nogapposntohomoplasyposn[donornode][recipientnode][translatedsnplocation]
#
#
#						
#
#	
#	if len(homoplasyposns)!=len(homoplasyposntonogapposn) or len(homoplasyposns)!=len(alignmentlengths):
#		return
#	
#	Final_blocks=[]
#	added=True
#	
#	roundnum=1
#	while added:
#		blocks=[]
#		
#		print " Round", roundnum, "...",
#		sys.stdout.flush(),
#
#		N=0.0
#		C=0.0
#		
#		for node in homoplasyposns.keys():
#		
#			for donor in homoplasyposns[node].keys():
#				if len(homoplasyposns[node][donor])>=minsnps:
#					N+=alignmentlengths[node][donor]
#					C+=len(homoplasyposns[node][donor])
#				else:
#					del homoplasyposns[node][donor]
#					del homoplasyposntonogapposn[node][donor]
#					del nogapposntohomoplasyposn[node][donor]
#			if len(homoplasyposns[node])==0:
#				del homoplasyposns[node]
#				del homoplasyposntonogapposn[node]
#				del nogapposntohomoplasyposn[node]
#		
#		print C, "sites remaining in homoplasy database.",
#		
#		for node in homoplasyposns.keys():
#		
#	
#			for donor in homoplasyposns[node].keys():
#		
#
#				donor_blocks=[]
#				donor_blocks=detect_blocks_using_moving_windows_new(treeObject, homoplasyposns[node][donor], alignmentlengths[node][donor], minsnps, N, C)
#				
#				
#				for x in range(0,len(donor_blocks)):
#					donor_blocks[x].append(node)
#					donor_blocks[x].append(donor)
#					
#					
#				blocks=blocks+donor_blocks
#			
#		
#		added=False
#		while not added and len(blocks)>0:
#			blocks.sort()
#			
#			minloglike=blocks[0][0]
#			
#			recipients={blocks[0][5]:[blocks[0][6]]}
#			
#			x=1
#			while x<len(blocks) and blocks[x][0]==minloglike:
#				
#				if not recipients.has_key(blocks[x][5]):
#					recipients[blocks[x][5]]=[blocks[x][6]]
#				else:
#					recipients[blocks[x][5]].append(blocks[x][6])
#			
#				x+=1
#			
#			blocks_with_min_ll=x
#			
#			recipient = recipients.keys()[0]
#			
#			common_ancestor=get_common_ancestor_of_taxon_list(treeObject,recipients[recipient])
#			alldonors=recipients[recipient]
#			donor=recipients[recipient][0]
#			
#			
#			oldtotalsnps=len(homoplasyposns[recipient][donor])
#			
#			#bit to remove homoplasies involved in the recombination identified
#			
#			#first identify which block was the one for the correct donor and recipient
#			for x in range(0,blocks_with_min_ll):
#				if blocks[x][5]==recipient and blocks[x][6]==donor:
#					blocktoremove=x
#					break
#			
#			start=nogapposntohomoplasyposn[recipient][donor][blocks[blocktoremove][1]]
#			end=nogapposntohomoplasyposn[recipient][donor][blocks[blocktoremove][2]]
#			
#			#remove homoplasies for donors and recipient in the recombination block
#				
#			for snplocation in homoplasyposns[recipient][donor][blocks[blocktoremove][3]:blocks[blocktoremove][4]+1]:
#				
#				alignmentsnplocation=nogapposntohomoplasyposn[recipient][donor][snplocation]
#				
#				for potentialdonor in homoplasyposns[recipient].keys():
#
#					remove_downstream_donors(recipient, potentialdonor, alignmentsnplocation)
#					
#					
#					
#					if homoplasyposntonogapposn[recipient][potentialdonor].has_key(alignmentsnplocation):
#					
#						translatedsnplocation=homoplasyposntonogapposn[recipient][potentialdonor][alignmentsnplocation]
#						#print "removing recipient ", recipient, potentialdonor, translatedsnplocation
#						homoplasyposns[recipient][potentialdonor].remove(translatedsnplocation)
#						del homoplasyposntonogapposn[recipient][potentialdonor][alignmentsnplocation]
#						del nogapposntohomoplasyposn[recipient][potentialdonor][translatedsnplocation]
#				
#					
#					
#
#			#Calculate the p-value of the block
#			
#			
#			blocklength=(blocks[blocktoremove][2]+1)-blocks[blocktoremove][1]
#			lennogaps=alignmentlengths[recipient][donor]
#			snpcount=(blocks[blocktoremove][4]+1)-blocks[blocktoremove][3]
#			
#			
#			
#			pvalue=1
#			if snpcount>0:
#				x=0
#				pvalue=0.0
#				while x<snpcount:
#					
#					part1=reduce_factorial(blocklength,x)-reduce_factorial(x,x)
#					part2=math.log((float(oldtotalsnps)/lennogaps),10)*x
#					part3=math.log((1.0-(float(oldtotalsnps)/lennogaps)),10)*(blocklength-x)
#				
#					logthing=part1 + part2 + part3
#					
#					pvalue+=10**logthing
#					x+=1
#				pvalue=1.0-round(pvalue,10)
#				pvaluethreshold=(0.05/float(lennogaps))
#				
#				Final_blocks.append({"start":start, "end":end, "ll":blocks[blocktoremove][0], "common_ancestor":common_ancestor, "donors":alldonors, "snpcount": snpcount, "p":pvalue, "removal_round":roundnum, "recipient":recipient})
#				
#				added=True
#				print str(donor)+"->"+str(recipient)+", "+str(start)+".."+str(end)+", "+str(snpcount)+" snps, -ll="+str(blocks[blocktoremove][0])+", pvalue="+str(pvalue)
#			else:
#				blocks=blocks[1:]
#			roundnum+=1
#		
#		if not added:
#			print "No blocks found"
#		
#	print "Found", len(Final_blocks), "homoplasy block(s)"
#	sys.stdout.flush()
#	print_blocks_to_tab(treeObject, Final_blocks, handle)



















def get_blocks_from_windowcounts(binsnps, windowcounts, cutoff, nongapposns):

	tempblocks=[]
	blockstart=0
	inblock=False
	minsnps=3
	x=0
	y=0
	
	while x<len(windowcounts):
	#for x, pvalue in enumerate(pvalues):
		#if count>0:
		#	print >> output, nongapposns[x]+1, windowcounts[x], X2[x], pvalues[x]
		value=windowcounts[x]

		
		#print x, pvalue, inblock
		
#		if value > cutoff:
#			print x, value
		
		if value>cutoff and not inblock:
			
			blockstart=nongapposns[x]+1
			inblock=True
		elif value<=cutoff and inblock:
				
			tempblocks.append([0.0,blockstart,nongapposns[x]+1])
			inblock=False
	
		x=x+1
		
	if inblock:
		tempblocks.append([0.0,blockstart,nongapposns[-1]])

	
	#print len(binsnps), nongapposns[-1], len(windowcounts)
	
	#Trim blocks using likelihood
	
	
	N,C=get_N_and_C(binsnps)
	
	newblocks=[]
	
	for block in tempblocks:
		
		
		#trim to first and last SNPs in block
		start=int(block[1])
		end=int(block[2])
		
		n,c=get_N_and_C(binsnps[start:end+1])

		if c<minsnps:
			continue

		
		
		if binsnps[start]!=1:
		
			for x, basetype in enumerate(binsnps[start: end]):
			
				if basetype==1:
					start=start+x
					break
					
		if binsnps[end]!=1:
			for x, basetype in enumerate(binsnps[end:start: -1]):
	
				if basetype==1:
					end=end-x
					break
		
		
		old_like=get_block_likelihood(start, end, binsnps, N, C)
		
		#print "initial likelihood=", old_like, "start=", start, "end=", end
		
		newstart=start
		oldstart=start
		for x, basetype in enumerate(binsnps[start+1: end]):
			
			if basetype==1:
				new_like=get_block_likelihood(x+start+1, end, binsnps, N, C)
				
				if new_like>old_like:
					start=newstart
					break
				else:
					newstart=start+x+1
					old_like=new_like
		
		
		if start==oldstart:
			newstart=start
			for x, basetype in enumerate(binsnps[start-1:0:-1]):
				
				if basetype==1:
					new_like=get_block_likelihood((start-1)-x, end, binsnps, N, C)
					
					if new_like>old_like:
						start=newstart
						break
					else:
						newstart=(start-1)-x
						old_like=new_like
		
		
		newend=end
		oldend=end
		for x, basetype in enumerate(binsnps[ end-1: start: -1]):
			if basetype==1:
				new_like=get_block_likelihood(start, (end-1)-x, binsnps, N, C)
				if new_like>old_like:
					end=newend
					break
				else:
					newend=(end-1)-x
					old_like=new_like
		
		if end==oldend:
			newend=end
			for x, basetype in enumerate(binsnps[ end+1:]):
				if basetype==1:
					new_like=get_block_likelihood(start, end+1+x, binsnps, N, C)
					if new_like>old_like:
						end=newend
						break
					else:
						newend=end+1+x
						old_like=new_like
		
		
		
		#print "new likelihood=", old_like, "start=", start, "end=", end
		block[0]=old_like
		block[1]=start
		block[2]=end
		snpcount=0
		for x, snp in enumerate(binsnps[start:end+1]):
			if snp==1:
				snpcount+=1
		if snpcount>=minsnps:
			newblocks.append([block[0], block[1], block[2]])

	
	return newblocks





################################################################
# Function to detect recombination regions using moving window #
################################################################


def detect_clusters_using_moving_windows(treeObject, binsnps, snpposns, nongapposns, node, donor):#donor_list=[]):
	
	window=100
	totallen=len(binsnps)
	X2=[]
	pvalues=[]
	currwindowcount=0
	currposn=0
	X2converter={}
	
#	snpposns=[]
#	gapposns=[]
#	nongapposns=[]
#	
#	for x, binsnp in enumerate(binsnps):
#		if binsnp==1:
#			snpposns.append(len(nongapposns))
#			nongapposns.append(x)
#		elif binsnp==2:
#			gapposns.append(x)
#		elif binsnp==0:
#			nongapposns.append(x)
	
	minsnps=3
	
	lennogaps=len(nongapposns)
	#genome_length=lennogaps/len(donor_list)
	
	
	totalsnps=float(len(snpposns))
	
	if totalsnps<minsnps:
		return []
	
	windowcounts=[0]*(int(lennogaps))
	
	window=int(float(lennogaps)/(totalsnps/10))
	
	if window<100:
		window=100
	elif window>lennogaps:
		window=lennogaps/2
	elif window>10000:
		window=10000
	
	#print lennogaps, totalsnps, window
	
	#print float(lennogaps)/(totalsnps), (totalsnps/float(lennogaps))
	
	threshold=1-(0.05/(float(lennogaps)/(window/10)))
	
	#print float(lennogaps)/window, threshold
	
	#sys.exit()
	
	for position in snpposns:
		
		y=position-(window/2)
		curposn=int(y)
		while (y+window)>curposn:
			if curposn<0:
				actualposn=lennogaps+curposn
			elif curposn>(lennogaps-1):
				actualposn=curposn-lennogaps
			else:
				actualposn=curposn
			#print actualposn, curposn, lennogaps
			windowcounts[actualposn]=windowcounts[actualposn]+1
			curposn=curposn+1

	
	
	added=True
	
	blocks=[]
	
	lastcutoff=-1
	
	while added and totalsnps>=minsnps:
	
	
		window=int(float(lennogaps)/(totalsnps/10))
		
		if window<100:
			window=100
		elif window>10000:
			window=10000
		
		#print lennogaps, totalsnps, window
		
		#print float(lennogaps)/(totalsnps), (totalsnps/float(lennogaps))
		
		threshold=1-(0.05/(float(lennogaps)/(window/10)))
		cutoff=0
		pvalue=0.0
		while pvalue<=threshold:
			#print window, cutoff, pvalue, threshold, totalsnps, reduce_factorial(float(window),cutoff), reduce_factorial(window,cutoff), reduce_factorial(cutoff,cutoff)
			part1=reduce_factorial(window,cutoff)-reduce_factorial(cutoff,cutoff)
			part2=math.log((float(totalsnps)/lennogaps),10)*cutoff
			part3=math.log((1.0-(float(totalsnps)/lennogaps)),10)*(window-cutoff)
			
			logthing=part1 + part2 + part3
			
			pvalue+=10**logthing
			
			cutoff+=1
			
			
		cutoff-=1
		
		
		if cutoff!=lastcutoff:
		
			newblocks=get_blocks_from_windowcounts(binsnps, windowcounts, cutoff, nongapposns)
				
				
			
		else:
			newblocks=newblocks[1:]
		
		lastcutoff=cutoff
		
		
		added=False
		if len(newblocks)>0:
			newblocks.sort()			
			
			snpcount=0
			oldtotalsnps=totalsnps
			oldlennogaps=lennogaps
			
			for x, snp in enumerate(binsnps[newblocks[0][1]:newblocks[0][2]+1]):
				if snp==1:
					snpcount+=1
					binsnps[newblocks[0][1]+x]=0
					totalsnps-=1
				lennogaps-=1
			
			
			if snpcount>=minsnps:
				numgaps=0
				for x in binsnps[newblocks[0][1]:newblocks[0][2]+1]:
					if x==2:
						numgaps+=1
				
				blocklen=(((newblocks[0][2]+1)-newblocks[0][1])-numgaps)
				x=0
				pvalue=0.0
				while x<snpcount:
				
					part1=reduce_factorial(blocklen,x)-reduce_factorial(x,x)
					part2=math.log((float(oldtotalsnps)/oldlennogaps),10)*x
					part3=math.log((1.0-(float(oldtotalsnps)/oldlennogaps)),10)*(blocklen-x)
				
					logthing=part1 + part2 + part3
					
					pvalue+=10**logthing
					x+=1
				pvalue=1.0-round(pvalue,10)
				pvaluethreshold=(0.05/float(lennogaps))
				#print blocklen, pvaluethreshold, snpcount, pvalue, oldtotalsnps, 1-threshold
				if pvalue<pvaluethreshold:
					print "here", pvalue, pvaluethreshold
					blocks.append([newblocks[0][1], newblocks[0][2], newblocks[0][0], snpcount, pvalue])
					added=True
				else:
					print "hereb", pvalue, pvaluethreshold

	tabout=open("test.tmp.tab","a")
	for block in blocks:
		downstreamnamelist=[]

		print >> tabout, "FT   misc_feature    "+str(block[0]+1)+".."+str(block[1]+1)
		print >> tabout, "FT                   /node="+str(node)
		print >> tabout, "FT                   /node="+str(donor)
#		if node==0 and options.outgroup!="" and options.outgroup!="None":
#			
#			editablealignment[options.outgroup]=editablealignment[options.outgroup][:block[0]]+"?"*(block[1]-block[0])+editablealignment[options.outgroup][block[1]:]
#			
#			
#			print >> tabout, "FT                   /colour=3"
			#print >> tabout, 'FT                   /taxa="'+options.outgroup+'"'
			#print >> tabout, 'FT                   /node="'+nodenames[1]+'->'+options.outgroup+'"'	
			
#		else:
#			for taxon in downstreamtaxa:
#				downstreamnamelist.append(sequencenames[taxon.split("_")[1]])
#				editablealignment[sequencenames[taxon.split("_")[1]]]=editablealignment[sequencenames[taxon.split("_")[1]]][:block[0]]+"?"*(block[1]-block[0])+editablealignment[sequencenames[taxon.split("_")[1]]][block[1]:]

			#This bit adds each block to the rec.tab output file
	
#			if treeObject.is_internal(daughter):
#				print >> tabout, "FT                   /colour=2"
#				#print >> tabout, 'FT                   /taxa="'+', '.join(downstreamnamelist)+'"'
#				#print >> tabout, 'FT                   /node="'+nodenames[1]+'->'+daughternames[daughter][1]+'"'
#						
#			else:
#				print >> tabout, "FT                   /colour=4"
				#print >> tabout, 'FT                   /taxa="'+sequencenames[daughternames[daughter][1]]+'"'
				#print >> tabout, 'FT                   /node="'+nodenames[1]+'->'+sequencenames[daughternames[daughter][1]]+'"'
			
		print >> tabout, 'FT                   /neg_log_likelihood='+str(block[2])
		print >> tabout, 'FT                   /SNP_count='+str(block[3])
		print >> tabout, 'FT                   /pvalue='+str(block[4])
	tabout.close()
	return blocks







################################################################
# Function to detect recombination regions using moving window #
################################################################


def detect_all_clusters_using_moving_windows(treeObject, binsnps, snpposns, nongapposns, node, donor):
	
	window=100
	totallen=len(binsnps)
	X2=[]
	pvalues=[]
	currwindowcount=0
	currposn=0
	X2converter={}
	
#	snpposns=[]
#	gapposns=[]
#	nongapposns=[]
#	
#	for x, binsnp in enumerate(binsnps):
#		if binsnp==1:
#			snpposns.append(len(nongapposns))
#			nongapposns.append(x)
#		elif binsnp==2:
#			gapposns.append(x)
#		elif binsnp==0:
#			nongapposns.append(x)
	
	minsnps=3
	
	lennogaps=len(nongapposns)

	
	totalsnps=float(len(snpposns))
	#print node, donor, totalsnps
	if totalsnps<minsnps:
		return []
	
	windowcounts=[0]*(int(lennogaps))
	
	window=int(float(lennogaps)/(totalsnps/10))
	
	if window<100:
		window=100
	elif window>lennogaps:
		window=lennogaps/2
	elif window>10000:
		window=10000
	
	#print lennogaps, totalsnps, window
	
	#print float(lennogaps)/(totalsnps), (totalsnps/float(lennogaps))
	
	#threshold=1-(0.05/(float(lennogaps)/(window/10)))
	
	#print float(lennogaps)/window, threshold
	
	#sys.exit()
	for position in snpposns:
		
		y=position-(window/2)
		curposn=int(y)
		while (y+window)>curposn:
			if curposn<0:
				actualposn=lennogaps+curposn
			elif curposn>(lennogaps-1):
				actualposn=curposn-lennogaps
			else:
				actualposn=curposn
			
			windowcounts[actualposn]=windowcounts[actualposn]+1
			curposn=curposn+1

	threshold=1-(0.05/(float(lennogaps)/(window/10)))
	cutoff=0
	pvalue=0.0
	while pvalue<=threshold:
		#print window, cutoff, pvalue, threshold, totalsnps, reduce_factorial(float(window),cutoff), reduce_factorial(window,cutoff), reduce_factorial(cutoff,cutoff)
		part1=reduce_factorial(window,cutoff)-reduce_factorial(cutoff,cutoff)
		part2=math.log((float(totalsnps)/lennogaps),10)*cutoff
		part3=math.log((1.0-(float(totalsnps)/lennogaps)),10)*(window-cutoff)
		
		logthing=part1 + part2 + part3
		
		pvalue+=10**logthing
		
		cutoff+=1
		
		
	cutoff-=1
	#print cutoff
	newblocks=[]
	if cutoff<=totalsnps and cutoff>=minsnps:
		#print "here"
		newblocks=get_blocks_from_windowcounts(binsnps, windowcounts, cutoff, nongapposns)
	
	return newblocks
	
	
	
	
	
	
	
def get_homoplasy_blocks(treeObject, handle):

	root=treeObject.root
	#handle=open("test.tab","w")


	def count_diffs(node1, node2, start, end):

		seq1=treeObject.node(node1).get_data().comment["sequence"][start:end]

		seq2=treeObject.node(node2).get_data().comment["sequence"][start:end]
		numdiffs=0
		for x, ambiguity1 in enumerate(seq1):

			bases1=set(ambiguity_to_bases[ambiguity1])
			bases2=set(ambiguity_to_bases[seq2[x]])

			if "-" in bases1:
				bases1.remove("-")
			elif "-" in bases2:
				bases2.remove("-")
			
			#print bases1, bases2, bases1.union(bases2)
			
			if len(bases1.intersection(bases2))==0:
				numdiffs+=1
		
		#print node1, node2, start, end, numdiffs
		return numdiffs
	
	
	
	def count_diffs_for_seqs(seq1, seq2):
		numdiffs=0
		for x, ambiguity1 in enumerate(seq1):

			bases1=set(ambiguity_to_bases[ambiguity1])
			bases2=set(ambiguity_to_bases[seq2[x]])

			if "-" in bases1:
				bases1.remove("-")
			elif "-" in bases2:
				bases2.remove("-")
			
			#print bases1, bases2, bases1.union(bases2)
			
			if len(bases1.intersection(bases2))==0 and (len(bases1)>0 or len(bases1)>0):
				numdiffs+=1
		
		#print numdiffs
		return numdiffs
	
	
		
		
	def get_consensus(seq1, seq2):
		
		consensus_seq=""
		
		numdiffs=0
		for x, ambiguity1 in enumerate(seq1):
		
			bases1=set(ambiguity_to_bases[ambiguity1])
			bases2=set(ambiguity_to_bases[seq2[x]])
			
			union=bases1.union(bases2)
			
			union_list=list(union)
			union_list.sort()
			
			consensus_seq=consensus_seq+bases_to_ambiguity[''.join(union_list)]
		
		return consensus_seq
	
	
	
	
	def find_blocks(node, final_blocks, block_improvement, block_key):
	
		data=treeObject.node(node).get_data().comment
		#root_branches=treeObject.node(root).get_succ()
		#if node==root_branches[1]:
		#	return
		
		if data.has_key("SNP_locations"):

			locations=data["SNP_locations"].keys()
			locations.sort()

			
			blocks={}
			new_blocks={}
			
			for location in locations:
				if data["SNP_locations"][location].homoplasy:

				   	
					for homoplasy in data["SNP_locations"][location].homoplasies:
						
						if homoplasy[0]=="r" and treeObject.common_ancestor(node, homoplasy[1])==homoplasy[1]:
							
							blocks[location]=[set(),"r", node,treeObject.node(node).get_prev()]
							blocks[location][0]=blocks[location][0].union(set([homoplasy[1]]+get_upstream_nodes(treeObject, homoplasy[1])))
							
							#remove the root from the list, as it has no prev
							
							if treeObject.root in blocks[location][0]:
								blocks[location][0].remove(treeObject.root)
						elif homoplasy[0]=="c":
							#print "cf"
							blocks[location]=[set(),"f",node, treeObject.node(node).get_prev()]
							#blocks[location][0]=blocks[location][0].union(set([homoplasy[1]]+get_downstream_nodes(treeObject, homoplasy[1])))
							blocks[location][0]=blocks[location][0].union(set(get_downstream_nodes(treeObject, homoplasy[1])))
							#blocks[location][0]=blocks[location][0].union(set([treeObject.node(homoplasy[1]).get_prev()]+get_downstream_nodes(treeObject, homoplasy[1])))#+get_downstream_nodes(treeObject, treeObject.node(homoplasy[1]).get_prev())))
							#print get_downstream_nodes(treeObject, homoplasy[1])
						else:
							#print "rf"
							blocks[location]=[set(),"f",node, treeObject.node(node).get_prev()]
							#blocks[location][0]=blocks[location][0].union(set([homoplasy[1]]+get_downstream_nodes(treeObject, homoplasy[1])))
							blocks[location][0]=blocks[location][0].union(set(get_downstream_nodes(treeObject, homoplasy[1])))
							#blocks[location][0]=blocks[location][0].union(set([treeObject.node(homoplasy[1]).get_prev()]+get_downstream_nodes(treeObject, treeObject.node(homoplasy[1]).get_prev())))
							
			#print blocks
			keys=blocks.keys()
			keys.sort()
			x=0
			while x+1<len(keys):


				if blocks[keys[x]][1]==blocks[keys[x+1]][1]:
					
					start=keys[x]
					end=keys[x+1]+1
				
				
					seq1=treeObject.node(blocks[keys[x]][2]).get_data().comment["sequence"][start:end]

					
					#print start, end, blocks[keys[x]][3], blocks[keys[x]][2], 
					
					seq2=treeObject.node(blocks[keys[x]][3]).get_data().comment["sequence"][start:end]
					
					origin_len=count_diffs_for_seqs(seq1, seq2)
					
					
					#origin_len=count_diffs(blocks[keys[x]][2], blocks[keys[x]][3], keys[x], keys[x+1]+1)
					
					possible_alternatives=blocks[keys[x]][0].intersection(blocks[keys[x+1]][0])
	
					alt_lengths=set()
	
					min_alt_len=10000000
					
					for alt in possible_alternatives:
						#print start, end, str(treeObject.node(alt).get_prev())+"->"+str(alt), blocks[keys[x]][2], 
						
						if treeObject.node(alt).get_prev()==treeObject.root:
							
							seq2=get_consensus(treeObject.node(treeObject.node(treeObject.root).get_succ()[0]).get_data().comment["sequence"][start:end], treeObject.node(treeObject.node(treeObject.root).get_succ()[1]).get_data().comment["sequence"][start:end])
						else:
							seq2=get_consensus(treeObject.node(treeObject.node(alt).get_prev()).get_data().comment["sequence"][start:end], treeObject.node(alt).get_data().comment["sequence"][start:end])
						length=count_diffs_for_seqs(seq1,seq2)
						#print length, alt, origin_len
						if length<min_alt_len and length<=origin_len:
							alt_lengths={}
							alt_lengths=set([alt])
							min_alt_len=length
						elif length==min_alt_len:
							alt_lengths.add(alt)
					
					
					#print "locations=", keys[x], keys[x+1]+1, "node=", blocks[keys[x]][2], "len=",  origin_len, alt_lengths#, blocks[keys[x]], blocks[keys[x+1]]
					
					if len(alt_lengths)>0:
						new_blocks[x+1]=[[],blocks[keys[x]][1],blocks[keys[x]][2], blocks[keys[x]][3]]
						new_blocks[x+1][0]=[keys[x], keys[x+1]+1,origin_len, alt_lengths]
				x=x+1

			#print blocks, len(blocks)
			if len(blocks)>0:
				
				last_homoplasy=keys[-1]
				first_homoplasy=keys[0]
				start=0
				end=len(treeObject.node(node).get_data().comment["sequence"])
				#end=50000
			
			
				seq1=treeObject.node(blocks[keys[x]][2]).get_data().comment["sequence"][start:first_homoplasy]+treeObject.node(blocks[keys[x]][2]).get_data().comment["sequence"][last_homoplasy:end]
				seq2=treeObject.node(blocks[keys[x]][3]).get_data().comment["sequence"][start:first_homoplasy]+treeObject.node(blocks[keys[x]][3]).get_data().comment["sequence"][last_homoplasy:end]
				
				
				origin_len=count_diffs_for_seqs(seq1, seq2)
				
				possible_alternatives=blocks[keys[0]][0]

				alt_lengths=set()

				min_alt_len=10000000
				
				for alt in possible_alternatives:
					if treeObject.node(alt).get_prev()==treeObject.root:
						seq2=get_consensus(treeObject.node(treeObject.node(treeObject.root).get_succ()[0]).get_data().comment["sequence"][start:first_homoplasy], treeObject.node(treeObject.node(treeObject.root).get_succ()[1]).get_data().comment["sequence"][start:first_homoplasy])+get_consensus(treeObject.node(treeObject.node(treeObject.root).get_succ()[0]).get_data().comment["sequence"][last_homoplasy:end], treeObject.node(treeObject.node(treeObject.root).get_succ()[1]).get_data().comment["sequence"][last_homoplasy:end])
					else:
						seq2=get_consensus(treeObject.node(treeObject.node(alt).get_prev()).get_data().comment["sequence"][start:first_homoplasy], treeObject.node(alt).get_data().comment["sequence"][start:first_homoplasy])+get_consensus(treeObject.node(treeObject.node(alt).get_prev()).get_data().comment["sequence"][last_homoplasy:end], treeObject.node(alt).get_data().comment["sequence"][last_homoplasy:end])
					length=count_diffs_for_seqs(seq1,seq2)
					if length<min_alt_len and length<=origin_len:
						alt_lengths={}
						alt_lengths=set([alt])
						min_alt_len=length
					elif length==min_alt_len:
						alt_lengths.add(alt)
				

				
				#print "locations=", 0, keys[0]+1, "node=", blocks[keys[0]][2], "len=",  origin_len, alt_lengths, min_alt_len

				if len(alt_lengths)>0:
						new_blocks[0]=[[],blocks[keys[0]][1],blocks[keys[0]][2], blocks[keys[0]][3]]
						new_blocks[0][0]=[0, keys[0]+1,origin_len, alt_lengths]
						new_blocks[x+1]=[[],blocks[keys[-1]][1], blocks[keys[-1]][2], blocks[keys[-1]][3]]
						new_blocks[x+1][0]=[keys[-1], end ,origin_len, alt_lengths]
			
			
			
			
			
			keys=new_blocks.keys()
			keys.sort()
			
			for key in keys:
				if new_blocks.has_key(key+1) and new_blocks[key][1]==new_blocks[key+1][1] and new_blocks[key][0][3].intersection(new_blocks[key+1][0][3]):
					new_blocks[key+1][0][3]=new_blocks[key][0][3].intersection(new_blocks[key+1][0][3])
					new_blocks[key+1][0][0]=new_blocks[key][0][0]
					del new_blocks[key]
			
			#print "NB", new_blocks
			
			for key in new_blocks.keys():
				if len(new_blocks[key][0][3])>1 and new_blocks[key][1]=="f":
#					common_ancestor=treeObject.common_ancestor(list(new_blocks[key][0][3])[0], list(new_blocks[key][0][3])[1])
#					for x in range(len(new_blocks[key][0][3])):
#						if treeObject.common_ancestor(common_ancestor, list(new_blocks[key][0][3])[x]) not in list(new_blocks[key][0][3]):
#							common_ancestor="None"
#							break
					common_ancestors=set(new_blocks[key][0][3])
					#print common_ancestors
					for x in range(len(new_blocks[key][0][3])):
						common_ancestors=common_ancestors.intersection(set([list(new_blocks[key][0][3])[x]]+get_upstream_nodes(treeObject, list(new_blocks[key][0][3])[x])))
						#print "HERE f", common_ancestors
				elif len(new_blocks[key][0][3])>1 and new_blocks[key][1]=="r":
					common_ancestors=set(new_blocks[key][0][3])
					#print common_ancestors
					for x in range(len(new_blocks[key][0][3])):
						common_ancestors=common_ancestors.intersection(set([list(new_blocks[key][0][3])[x]]+get_downstream_nodes(treeObject, list(new_blocks[key][0][3])[x])))
						#print "HERE r", common_ancestors
				elif len(new_blocks[key][0][3])==1:
						common_ancestors=new_blocks[key][0][3]
				
				if len(common_ancestors)>0:
					new_blocks[key][0][3]=common_ancestors
				else:
					print "no common ancestor", new_blocks[key][3]
			
			
			
			
			for key in new_blocks.keys():
			
				start=new_blocks[key][0][0]
				end=new_blocks[key][0][1]
		
				seq1=treeObject.node(node).get_data().comment["sequence"][start:end]

				
				#print start, end, blocks[keys[x]][3], blocks[keys[x]][2], 
				
				seq2=treeObject.node(treeObject.node(node).get_prev()).get_data().comment["sequence"][start:end]
				
				min_count=count_diffs_for_seqs(seq1, seq2)
				#min_count=count_diffs(node, treeObject.node(node).get_prev(), new_blocks[key][0][0], new_blocks[key][0][1])
				node_snps=min_count
				#print node_snps
				min_alt=""
				for alt in new_blocks[key][0][3]:
					if treeObject.node(alt).get_prev()==treeObject.root:
						seq2=get_consensus(treeObject.node(treeObject.node(treeObject.root).get_succ()[0]).get_data().comment["sequence"][start:end], treeObject.node(treeObject.node(treeObject.root).get_succ()[1]).get_data().comment["sequence"][start:end])
					else:
						seq2=get_consensus(treeObject.node(treeObject.node(alt).get_prev()).get_data().comment["sequence"][start:end], treeObject.node(alt).get_data().comment["sequence"][start:end])
					alt_count=count_diffs_for_seqs(seq1, seq2)
					#alt_count=count_diffs(new_blocks[key][2], alt, new_blocks[key][0][0], new_blocks[key][0][1])
					if alt_count<min_count:
						min_count=alt_count
						min_alt=alt
				#print node_snps, min_count, min_alt
				if min_alt!="" and (min_count+10)<node_snps:# and min_count<node_snps:#
					
					
				
					final_blocks[block_key]={"start":new_blocks[key][0][0], "end":new_blocks[key][0][1], "from_node":new_blocks[key][3], "to_node": new_blocks[key][2], "to_rec":min_alt, "from_rec":treeObject.node(min_alt).get_prev(), "rec_snps":min_count, "node":node, "node_snps":node_snps}
					
					block_improvement.append([node_snps-min_count,block_key])
					block_key+=1
						
			
		#print node, new_blocks
			
			
		return final_blocks, block_improvement, block_key	
			
			
			

	def iterate_nodes(node, final_blocks, block_improvement, block_key):
		daughters=treeObject.node(node).get_succ()

		for daughter in daughters:
			final_blocks, block_improvement, block_key=iterate_nodes(daughter, final_blocks, block_improvement, block_key)

		final_blocks, block_improvement, block_key=find_blocks(node, final_blocks, block_improvement, block_key)
		
		return final_blocks, block_improvement, block_key

	final_blocks={}
	block_improvement=[]
	block_key=0

	final_blocks, block_improvement, block_key=iterate_nodes(root, final_blocks, block_improvement, block_key)
	
	
	
	block_improvement.sort()
	block_improvement=block_improvement[::-1]
	boiled_down={}
	
	for x, num in enumerate(block_improvement):
			block_key=num[1]
			
			if not final_blocks.has_key(block_key):
				continue
			
			start=final_blocks[block_key]["start"]
			end=final_blocks[block_key]["end"]
			for numb in block_improvement[x+1:]:
				block_keyb=numb[1]
				
				if not final_blocks.has_key(block_keyb):
					continue
				if not final_blocks.has_key(block_key):
					break	
				
				startb=final_blocks[block_keyb]["start"]
				endb=final_blocks[block_keyb]["end"]
				if (startb>=start and startb<end) or (endb>start and endb<=end) or (startb<=start and endb>=end):
					if (final_blocks[block_key]["to_rec"] in [final_blocks[block_keyb]["to_rec"], final_blocks[block_keyb]["to_node"]]) or (final_blocks[block_keyb]["to_rec"] in [final_blocks[block_key]["to_rec"], final_blocks[block_key]["to_node"]]):
						#print final_blocks[block_key]
						#print final_blocks[block_keyb]
						
						if start<startb:
							new_start=start
						else:
							new_start=startb
						if end>endb:
							new_end=end
						else:
							new_end=endb
						
						#print new_start, new_end
						
						seq1=treeObject.node(final_blocks[block_key]["to_node"]).get_data().comment["sequence"][new_start:new_end]
						seq2=treeObject.node(final_blocks[block_key]["from_node"]).get_data().comment["sequence"][new_start:new_end]
						originalcount=count_diffs_for_seqs(seq1, seq2)
						
						
						seq2=get_consensus(treeObject.node(final_blocks[block_key]["from_rec"]).get_data().comment["sequence"][new_start:new_end], treeObject.node(final_blocks[block_key]["to_rec"]).get_data().comment["sequence"][new_start:new_end])
						reccount=count_diffs_for_seqs(seq1, seq2)
						
						seq1=treeObject.node(final_blocks[block_keyb]["to_node"]).get_data().comment["sequence"][new_start:new_end]
						seq2=treeObject.node(final_blocks[block_keyb]["from_node"]).get_data().comment["sequence"][new_start:new_end]
						originalcountb=count_diffs_for_seqs(seq1, seq2)
						
						seq2=get_consensus(treeObject.node(final_blocks[block_keyb]["from_rec"]).get_data().comment["sequence"][new_start:new_end], treeObject.node(final_blocks[block_keyb]["to_rec"]).get_data().comment["sequence"][new_start:new_end])
						reccountb=count_diffs_for_seqs(seq1, seq2)
						
						
						
						if (originalcount-reccount)>(originalcountb-reccountb) and (originalcount-reccount)>(final_blocks[block_key]["node_snps"]-final_blocks[block_key]["rec_snps"]):
							#print "A", originalcount, reccount, originalcount-reccount, originalcountb, reccountb, originalcountb-reccountb
							final_blocks[block_key]["start"]=new_start
							final_blocks[block_key]["end"]=new_end
							
						elif (originalcount-reccount)>(originalcountb-reccountb) and (originalcountb-reccountb)>(final_blocks[block_key]["node_snps"]-final_blocks[block_key]["rec_snps"]):
							print "B", originalcount, reccount, originalcount-reccount, originalcountb, reccountb, originalcountb-reccountb
							final_blocks[block_keyb]["start"]=new_start
							final_blocks[block_keyb]["end"]=new_end
							final_blocks[block_key]=final_blocks[block_keyb]
						
						del final_blocks[block_keyb]
					
					
						
						
						

	for key in final_blocks.keys():
		if treeObject.is_terminal(final_blocks[key]["to_rec"]):
			to_rec=treeObject.node(final_blocks[key]["to_rec"]).get_data().taxon
		else:
			to_rec=str(final_blocks[key]["to_rec"])
		if ["from_rec"]==treeObject.root:
			from_rec="Root"
		else:
			from_rec=str(final_blocks[key]["from_rec"])
		if treeObject.is_terminal(final_blocks[key]["to_node"]):
			to_node=treeObject.node(final_blocks[key]["to_node"]).get_data().taxon
		else:
			to_node=str(final_blocks[key]["to_node"])
		if ["from_node"]==treeObject.root:
			from_node="Root"
		else:
			from_node=str(final_blocks[key]["from_node"])
		
		
		print >> handle, "FT   recombination   "+str(final_blocks[key]["start"]+1)+".."+str(final_blocks[key]["end"])
		print >> handle, 'FT                   /recipient_branch='+from_node+"->"+to_node
		print >> handle, 'FT                   /donor_branch='+from_rec+"->"+to_rec
		print >> handle, "FT                   /original_branch_SNPs="+str(final_blocks[key]["node_snps"])
		print >> handle, "FT                   /recombination_branch_SNPs="+str(final_blocks[key]["rec_snps"])
#		print "FT   recombination   "+str(final_blocks[key]["start"]+1)+".."+str(final_blocks[key]["end"])
#		print 'FT                   /recipient_branch='+from_node+"->"+to_node
#		print 'FT                   /donor_branch='+from_rec+"->"+to_rec
#		print "FT                   /original_branch_SNPs="+str(final_blocks[key]["node_snps"])
#		print "FT                   /recombination_branch_SNPs="+str(final_blocks[key]["rec_snps"])
	
	handle.close()



		